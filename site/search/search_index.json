{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Meraki Home Assistant Integration Documentation","text":"<p>Welcome to the central documentation for the Meraki Home Assistant Integration. This collection of documents provides information on the requirements, design, and architecture of the integration.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<p>Please explore the different sections to find the information you need:</p> <ul> <li> <p>Requirements   This section outlines the functional and technical requirements for the integration. It details what the integration should do, from core API communication to specific features for different Meraki device types.</p> </li> <li> <p>Design   This section provides high-level design documents, explaining the overall architecture and outlining the design for specific features like the event log viewer and guest Wi-Fi management.</p> </li> <li> <p>Architecture &amp; Development   This section contains in-depth architectural documents, refactoring plans, and developer setup guides. It's the best place to find information about the codebase's structure, development environment, and plans for future improvements.</p> </li> <li> <p>Testing   This section contains the testing plan for the integration, outlining the strategy for ensuring code quality and reliability.</p> </li> </ul> <p>For guidelines on how to contribute to this documentation, please see the AGENTS.md file.</p>"},{"location":"AGENTS/","title":"Agent Guidelines for Documentation","text":"<p>Hello, fellow agent! This document provides guidelines for maintaining the documentation within this <code>docs</code> directory. Following these guidelines will ensure the documentation remains organized, consistent, and useful for everyone.</p>"},{"location":"AGENTS/#1-documentation-structure","title":"1. Documentation Structure","text":"<p>The documentation is organized into the following subdirectories. Before creating a new document, please check if a suitable location already exists.</p> <ul> <li><code>/requirements</code>: For functional and non-functional requirements of the integration.</li> <li><code>/design</code>: For high-level design specifications of new features.</li> <li><code>/architecture</code>: For in-depth architectural discussions, refactoring plans, and developer setup guides.</li> <li><code>/testing</code>: For test plans and quality assurance strategies.</li> </ul> <p>The main entry point for the documentation is the <code>README.md</code> file in this directory.</p>"},{"location":"AGENTS/#2-creating-new-documents","title":"2. Creating New Documents","text":"<p>ALWAYS use the template.</p> <p>Before creating any new document, you must start by copying the contents of <code>template.md</code>. This ensures all documents have a consistent structure.</p> <ul> <li>File Naming: Use lowercase letters and underscores (<code>_</code>) instead of spaces (e.g., <code>new_feature_design.md</code>).</li> <li>Location: Place the new document in the most relevant subdirectory.</li> </ul>"},{"location":"AGENTS/#3-when-to-create-vs-when-to-update","title":"3. When to Create vs. When to Update","text":"<ul> <li>Update an existing document if your changes are an incremental improvement or a minor correction to the information already present.</li> <li>Create a new document if you are documenting a completely new feature, a major architectural change, or a new set of requirements that don't fit well within an existing document.</li> </ul>"},{"location":"AGENTS/#4-updating-the-table-of-contents","title":"4. Updating the Table of Contents","text":"<p>If you add a new major document that should be easily discoverable (e.g., a new top-level design document), you must also add a link to it in the main <code>README.md</code> file located in this <code>docs</code> directory.</p> <p>Thank you for helping to keep our documentation clean and organized!</p>"},{"location":"development/","title":"Development Guide","text":"<p>This document provides instructions for setting up a development environment for the Meraki Home Assistant integration.</p>"},{"location":"development/#backend-development","title":"Backend Development","text":"<p>The backend of the integration is written in Python and uses the <code>meraki</code> library to interact with the Meraki API.</p> <p>**Backend Code Location</p> <p>The source code for the backend is located in the <code>custom_components/meraki_ha/</code> directory.</p> <p>**Installing Dependencies</p> <p>To work with the backend code, you must first install the necessary Python dependencies. It is recommended to use a virtual environment to avoid conflicts with other projects.</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip install -r requirements_dev.txt\n</code></pre> <p>**Running the Linter and Tests</p> <p>To ensure that your code is up to the project's standards, you should run the linter and tests before submitting a pull request.</p> <pre><code>ruff check .\nruff format .\nmypy .\nbandit -c .bandit.yaml -r .\npytest\n</code></pre>"},{"location":"development/#frontend-development","title":"Frontend Development","text":"<p>The Meraki side panel is a modern web application built with React, Vite, and TypeScript.</p> <p>**Frontend Code Location</p> <p>The source code for the frontend panel is located in the <code>custom_components/meraki_ha/www/</code> directory.</p> <p>**Frontend Dependencies</p> <p>To work with the frontend code, you must first install the necessary Node.js dependencies. Navigate to the frontend directory and run the following command:</p> <pre><code>cd custom_components/meraki_ha/www/\nnpm install\n</code></pre> <p>**Building the Frontend</p> <p>After making changes to the frontend code, you must rebuild the panel to generate the final JavaScript and CSS files. To do this, run the following command from the <code>custom_components/meraki_ha/www/</code> directory:</p> <pre><code>npm run build\n</code></pre> <p>This will compile the frontend application and place the necessary <code>meraki-panel.js</code> and <code>style.css</code> files in the <code>custom_components/meraki_ha/www/</code> directory. These are the files that are served to Home Assistant.</p> <p>**Development Server</p> <p>For a more interactive development experience, you can run the Vite development server:</p> <pre><code>npm run dev\n</code></pre> <p>This will start a local server, typically on port 5173, that provides hot-reloading as you make changes to the code. Note that when running in this mode, the panel will not have access to the Home Assistant <code>hass</code> object and may not function completely, but it is useful for UI and styling work.</p>"},{"location":"meraki_ha_webui_refactor/","title":"Meraki Home Assistant Integration Web UI Refactor","text":"<p>This document outlines the requirements for a comprehensive refactor of the Meraki Home Assistant integration's web UI. The goal is to transform the existing static view into a dynamic, informative, and user-friendly dashboard that provides a real-time overview of the Meraki network's status and health.</p>"},{"location":"meraki_ha_webui_refactor/#core-principles","title":"Core Principles","text":"<ol> <li>Dashboard First: The primary view will be a high-level dashboard that provides an at-a-glance summary of the entire Meraki organization.</li> <li>Drill-Down Capability: Users must be able to click on any summary metric or device to access a detailed view with all relevant information.</li> <li>Proactive Communication: The UI should display not just the status of devices but also the reasons for that status, using information logged in the backend.</li> <li>Modern UI/UX: The interface will be a modern, responsive web application that works on both mobile and desktop and adapts to the user's browser theme (light/dark mode).</li> <li>State-Driven Interface: The UI will be a passive consumer of a live data feed from the Home Assistant backend via WebSockets, ensuring a performant and efficient user experience.</li> </ol>"},{"location":"meraki_ha_webui_refactor/#architecture-design","title":"Architecture &amp; Design","text":"<p>The new UI will be a single-page application (SPA) built with React and styled with Tailwind CSS.</p> <ul> <li>Data Model: A dedicated WebSocket API endpoint will serve a centralized data payload containing device counts, a list of all discovered entities with their properties, and a new <code>status_messages</code> field on each device for human-readable log information.</li> <li>Component Hierarchy:</li> <li><code>App.tsx</code>: The main component that manages application state, the WebSocket connection, and client-side routing.</li> <li><code>Dashboard.tsx</code>: Displays high-level metrics using <code>StatusCard</code> components and a summary table of devices.</li> <li><code>DeviceView.tsx</code>: Displays detailed information for a single device.</li> <li><code>StatusCard.tsx</code>: A reusable component for displaying a single metric.</li> <li><code>DeviceTable.tsx</code>: A searchable, sortable table of all discovered Meraki devices.</li> <li>Styling: Tailwind's <code>dark:</code> modifier will be used for dark mode. The font will be <code>Inter</code>.</li> </ul>"},{"location":"meraki_ha_webui_refactor/#implementation-plan","title":"Implementation Plan","text":"<p>**Phase 1: Backend Data &amp; API</p> <ol> <li>Create WebSocket Endpoint:</li> <li>Define a WebSocket handler in <code>custom_components/meraki_ha/api/websocket.py</code>.</li> <li>The handler will send a complete data snapshot on connection and push updates when the coordinator's data changes.</li> <li>Enrich Data with Status Messages:</li> <li>Add a <code>status_messages</code> list to each device's data payload in the Meraki data coordinator.</li> <li>Log significant events to this list for display in the UI.</li> </ol> <p>**Phase 2: Frontend Foundation (React)</p> <ol> <li>Set up the React App:</li> <li>Create a new React app in <code>custom_components/meraki_ha/www</code>.</li> <li>Connect to Backend:</li> <li>Establish a WebSocket connection in <code>App.tsx</code> to receive data from the Home Assistant backend.</li> <li>Implement Routing:</li> <li>Create a simple state-based routing system in <code>App.tsx</code>.</li> </ol> <p>**Phase 3: Dashboard &amp; Core Components</p> <ol> <li>Build <code>StatusCard.tsx</code>:</li> <li>Create a reusable component for displaying metrics.</li> <li>Build <code>Dashboard.tsx</code>:</li> <li>Create a responsive card layout for key metrics.</li> <li>Build <code>DeviceTable.tsx</code>:</li> <li>Create a searchable, sortable table of devices.</li> </ol> <p>**Phase 4: Device Details &amp; Final Touches</p> <ol> <li>Build <code>DeviceView.tsx</code>:</li> <li>Display detailed information for a single device, including <code>status_messages</code>.</li> <li>Implement Dark Mode:</li> <li>Ensure all components support dark mode.</li> <li>Add Final Polish:</li> <li>Implement smooth transitions, icons, and ensure proper spacing.</li> </ol>"},{"location":"template/","title":"[Document Title]","text":"<p>Status: Draft | In Review | Approved Owner: @username Last Updated: YYYY-MM-DD</p>"},{"location":"template/#1-overview","title":"1. Overview","text":"<p>A brief, one-paragraph summary of the document's purpose. What is this document about? What problem does it solve or what feature does it describe?</p>"},{"location":"template/#2-requirements-if-applicable","title":"2. Requirements (if applicable)","text":"<p>If this document describes a new feature, list the functional and non-functional requirements here. Use a list or a table.</p> <ul> <li>Requirement 1: ...</li> <li>Requirement 2: ...</li> </ul> Requirement ID Description Priority REQ-001. ... High REQ-002. ... Medium"},{"location":"template/#3-design-if-applicable","title":"3. Design (if applicable)","text":"<p>Describe the proposed design. This can include architecture diagrams, UI mockups, data models, and API endpoint descriptions.</p> <p>**3.1. High-Level Architecture</p> <p>A diagram or description of the overall system architecture.</p> <p>**3.2. UI/UX Mockups</p> <p>Embed or link to mockups for any user interface changes.</p> <p>**3.3. Data Model</p> <p>Describe any new or modified data models.</p>"},{"location":"template/#4-implementation-details-if-applicable","title":"4. Implementation Details (if applicable)","text":"<p>Provide details about the implementation. This could include code snippets, library choices, and descriptions of key algorithms or logic.</p>"},{"location":"template/#5-open-questions-decisions","title":"5. Open Questions &amp; Decisions","text":"<p>List any open questions that need to be resolved or key decisions that were made during the design process.</p>"},{"location":"design/","title":"Design Document","text":"<p>This document outlines the design of the Meraki Home Assistant integration.</p>"},{"location":"design/#overview","title":"Overview","text":"<p>The Meraki Home Assistant integration allows users to monitor and control their Meraki networks and devices within Home Assistant. The integration is built around a central data update coordinator that fetches data from the Meraki API and distributes it to the various platforms (e.g., sensor, switch, device_tracker).</p>"},{"location":"design/#architecture","title":"Architecture","text":"<p>The integration is divided into the following components:</p> <ul> <li><code>__init__.py</code>: The main entry point for the integration. It sets up the coordinators and platforms.</li> <li><code>core</code>: A directory containing the core components of the integration, including the API client, coordinators, and entities.</li> <li><code>api</code>: A wrapper around the Meraki Dashboard API that provides a simplified interface for making API calls. This is implemented in the <code>core/api/client.py</code> file.</li> <li><code>coordinators</code>: The data update coordinators that fetch data from the Meraki API and manage the state of the integration. These are implemented in the <code>core/coordinators</code> directory.</li> <li><code>entities</code>: The base classes for the entities in the integration. These are implemented in the <code>core/entities</code> directory.</li> <li><code>platforms</code>: The platform-specific implementations of the entities, such as sensors, switches, and device trackers.</li> <li><code>const.py</code>: A file that contains all of the constants used in the integration.</li> <li><code>AGENTS.md</code>: A file that contains guidelines for agents working on the codebase.</li> </ul>"},{"location":"design/#error-handling","title":"Error Handling","text":"<p>The integration uses a centralized error handling strategy to ensure that all errors are handled consistently and that user-friendly error messages are displayed. The <code>@handle_meraki_errors</code> decorator is used to wrap all API calls and to handle any errors that may occur. The decorator logs the errors and raises a more specific exception from the <code>core.errors</code> module. This allows the calling code to handle different types of errors in a more granular way.</p>"},{"location":"design/#data-flow","title":"Data Flow","text":"<p>The integration uses a hybrid data retrieval strategy that combines polling with webhooks.</p> <ul> <li>Polling: The <code>MerakiDataUpdateCoordinator</code> fetches data from the Meraki API at a regular interval. This is used to get the initial state of the integration and to periodically refresh the data.</li> <li>Webhooks: The integration also uses webhooks to receive real-time updates from the Meraki API. This is used to get real-time updates for things like device status and client connectivity.</li> </ul> <p>The data flow for the integration is as follows:</p> <ol> <li>The <code>MerakiDeviceCoordinator</code> and <code>MerakiNetworkCoordinator</code> fetch data from the Meraki API at a regular interval.</li> <li>Each coordinator stores its data in its own <code>data</code> attribute.</li> <li>The platforms (e.g., sensor, switch, device_tracker) access the data from the appropriate coordinator and update their state accordingly.</li> <li>The integration also receives real-time updates from the Meraki API via webhooks.</li> <li>The <code>async_handle_webhook</code> function processes the data from the webhook and updates the state of the integration accordingly.</li> </ol>"},{"location":"design/#coordinators","title":"Coordinators","text":"<p>The integration uses two coordinators, which are located in the <code>core/coordinators</code> directory:</p> <ul> <li><code>MerakiDeviceCoordinator</code>: This coordinator is responsible for fetching data for all physical Meraki devices in the organization. It fetches base device data, and then enhances it with device-specific data like port statuses for switches, uplink information for appliances, and sensor readings for MT sensors. For cameras, it fetches the video settings and the video link for all cameras.</li> <li><code>MerakiNetworkCoordinator</code>: This coordinator fetches data for all networks, clients, and SSIDs in the organization. It also filters out disabled SSIDs.</li> </ul>"},{"location":"design/#platforms","title":"Platforms","text":"<p>The integration provides the following platforms:</p> <ul> <li><code>sensor</code>: The sensor platform provides sensors for monitoring the following:</li> <li>The status of Meraki devices (e.g., online, offline).</li> <li>The number of clients connected to each routing (MX/GX), wireless (MR/GR), and switch (MS) device.</li> <li>The number of clients connected to each SSID.</li> <li>The status of the WAN connection for MX devices.</li> <li>Data usage for MX appliances.</li> <li>PoE usage for MS switches.</li> <li>Port counts (in use/available) for MS switches.</li> <li>The radio settings for MR devices.</li> <li>The status of the SSIDs.</li> <li>The splash page, auth mode, encryption mode, WPA encryption mode, IP assignment mode, band selection, per-client bandwidth limits, per-SSID bandwidth limits, and visibility of the SSIDs.</li> <li>Environmental readings (temperature, humidity, water detection) for MT sensors.</li> <li><code>switch</code>: The switch platform provides switches for controlling the following:</li> <li>The state of the SSIDs (e.g., enabled, disabled).</li> <li>The broadcast state of the SSIDs.</li> <li>The state of the camera sense feature for MV cameras.</li> <li>The state of the audio detection feature for MV cameras.</li> <li>The state of the RTSP server for MV cameras.</li> <li><code>device_tracker</code>: The device tracker platform provides device trackers for monitoring the presence of clients on the network.</li> <li><code>text</code>: The text platform provides text entities for displaying the following:</li> <li>The name of the SSIDs.</li> <li>The status of the SSIDs.</li> </ul>"},{"location":"design/#code-duplication-and-refactoring-opportunities","title":"Code Duplication and Refactoring Opportunities","text":"<p>**Device Sensor Base Class</p> <p>The device sensor platforms in <code>custom_components/meraki_ha/sensor/device</code> have a lot of duplicated code. A base class could be created to handle the following:</p> <ul> <li><code>__init__</code> method: The base class could handle the common initialization logic, such as setting the unique ID, name, and icon.</li> <li><code>device_info</code> property: The base class could provide a default implementation of the <code>device_info</code> property.</li> <li><code>_handle_coordinator_update</code> method: The base class could provide a default implementation of the <code>_handle_coordinator_update</code> method.</li> <li><code>available</code> property: The base class could provide a default implementation of the <code>available</code> property.</li> <li><code>_get_current_device_data</code> method: The base class could provide a helper method to get the current device data from the coordinator.</li> </ul> <p>By creating a base class, we can significantly reduce the amount of duplicated code and make the sensor platforms easier to maintain.</p>"},{"location":"design/event_log_viewer/","title":"Design Proposal: Event / Alert Log Viewer","text":"<p>This document outlines the design for the \"Event / Alert Log Viewer\" feature for the Meraki Home Assistant integration's web UI.</p>"},{"location":"design/event_log_viewer/#1-feature-goal","title":"1. Feature Goal","text":"<p>To provide a clear, filterable, and searchable view of network events and alerts from the Meraki dashboard directly within the Home Assistant web UI. This will allow for quick diagnostics and monitoring without needing to leave the Home Assistant environment.</p>"},{"location":"design/event_log_viewer/#2-ui-design","title":"2. UI Design","text":"<p>A new page in the web UI called \"Event Log\" will be created, accessible from the main sidebar.</p> <p>**Main View</p> <p>The page will feature a table displaying the event logs. Each row will represent a single event with the following columns:</p> <ul> <li>Timestamp: When the event occurred.</li> <li>Event Type: A short, descriptive category for the event (e.g., \"Client Connected\", \"Device Disconnected\", \"Firewall Rule Blocked\").</li> <li>Description: A detailed message about the event.</li> <li>Severity: A color-coded indicator (e.g., \"Info\", \"Warning\", \"Alert\") to quickly identify important events.</li> </ul> <p>**Controls</p> <p>Above the table, there will be several controls to help users find the information they need:</p> <ul> <li>Time Range Filter: A dropdown to select common time ranges (e.g., \"Last Hour,\" \"Last 24 Hours\") and a custom date/time picker.</li> <li>Event Type Filter: A multi-select dropdown to show or hide specific categories of events.</li> <li>Search Bar: A text input to search for keywords within the event descriptions.</li> </ul> <p>**UI Sketch</p> <pre><code>---------------------------------------------------------------------\n| Event Log                                                         |\n---------------------------------------------------------------------\n|                                                                   |\n|  Time Range: [ Last 24 Hours \u25bc ]  Filter: [ All Types \u25bc ]  [ Search... ] |\n|                                                                   |\n|  -----------------------------------------------------------------  |\n|  | Timestamp           | Type                  | Description      |\n|  -----------------------------------------------------------------  |\n|  | 2025-08-20 19:00:00 | Client Connected      | John's iPad...   |\n|  | 2025-08-20 18:55:12 | Device Disconnected   | Living Room AP...|\n|  | 2025-08-20 18:52:03 | Content Blocked       | Gaming site...   |\n|                                                                   |\n---------------------------------------------------------------------\n</code></pre>"},{"location":"design/event_log_viewer/#3-implementation-plan-instructions-for-a-continuing-agent","title":"3. Implementation Plan &amp; Instructions for a Continuing Agent","text":"<p>This section provides a detailed plan for an agent to implement this feature.</p> <p>**Goal</p> <p>Implement the \"Event / Alert Log Viewer\" as described in the design proposal.</p> <p>**Prerequisites</p> <ul> <li>Familiarity with React (functional components, hooks like <code>useState</code> and <code>useEffect</code>).</li> <li>Understanding of how to make API calls in JavaScript using <code>fetch</code>.</li> <li>Basic knowledge of the existing web UI structure (<code>App.jsx</code>, <code>Sidebar.jsx</code>, and the <code>pages</code> directory).</li> </ul> <p>**Step-by-Step Implementation Plan</p>"},{"location":"design/event_log_viewer/#1-backend-create-the-api-endpoint","title":"**1. Backend: Create the API Endpoint","text":"<ul> <li>File to Modify: <code>custom_components/meraki_ha/web_server.py</code></li> <li> <p>Tasks:</p> </li> <li> <p>Add a new route, <code>/api/events</code>, to the <code>_setup_routes</code> method.</p> </li> <li>Create a new handler function, <code>handle_api_events</code>, for this route.</li> <li>This handler should accept query parameters for filtering (e.g., <code>startTime</code>, <code>endTime</code>, <code>eventType</code>).</li> <li>Inside the handler, use the <code>self.coordinator.api_client</code> to call the Meraki Dashboard API endpoint to fetch the events. The primary endpoint to investigate is <code>GET /networks/{networkId}/events</code>. You may need to fetch events for all networks and combine them, or use an organization-level endpoint if available.</li> <li>Process the data from the Meraki API into a clean JSON format suitable for the frontend and return it.</li> </ul>"},{"location":"design/event_log_viewer/#2-frontend-build-the-ui","title":"**2. Frontend: Build the UI","text":"<ul> <li> <p>Task 1: Create the Event Log Page</p> </li> <li> <p>Create a new file: <code>custom_components/meraki_ha/web_ui/src/pages/EventLogPage.jsx</code>.</p> </li> <li>In this file, create a new React component named <code>EventLogPage</code>.</li> <li>Use <code>useState</code> to manage the state for the event logs, loading status, errors, and filter values.</li> <li>Use <code>useEffect</code> to make an initial <code>fetch</code> call to your new <code>/api/events</code> endpoint when the component mounts.</li> <li> <p>Render the UI as described in the design proposal (the filter controls and the table).</p> </li> <li> <p>Task 2: Add Navigation</p> </li> <li> <p>File to Modify: <code>custom_components/meraki_ha/web_ui/src/components/Sidebar.jsx</code></p> </li> <li> <p>Task: Add a new <code>NavLink</code> to the sidebar for the \"Event Log\" page, pointing to the <code>/events</code> route. Choose a suitable icon.</p> </li> <li> <p>Task 3: Add the Route</p> </li> <li>File to Modify: <code>custom_components/meraki_ha/web_ui/src/App.jsx</code></li> <li>Task: Add a new <code>&lt;Route&gt;</code> for the <code>/events</code> path that renders your new <code>EventLogPage</code> component.</li> </ul>"},{"location":"design/event_log_viewer/#3-build-and-verify","title":"**3. Build and Verify","text":"<ul> <li>Task 1: Build the Frontend</li> <li>Navigate to the <code>custom_components/meraki_ha/web_ui/</code> directory.</li> <li>Run the command <code>npm run build</code> to compile the new frontend code.</li> <li>Task 2: Verify with a Test Script</li> <li>Create a new Playwright script (e.g., <code>jules-scratch/verification/verify_event_log.py</code>).</li> <li>The script should:<ol> <li>Start a local web server for the <code>dist</code> directory.</li> <li>Navigate to the web UI.</li> <li>Click the \"Event Log\" link in the sidebar.</li> <li>Verify that the \"Event Log\" page loads correctly and that the event table is visible.</li> <li>Take a screenshot of the page.</li> </ol> </li> </ul>"},{"location":"design/guest_wifi/","title":"Design Proposal: Guest Wi-Fi Management (with Splash Page)","text":"<p>This document outlines the design for the \"Guest Wi-Fi Management\" feature for the Meraki Home Assistant integration's web UI.</p>"},{"location":"design/guest_wifi/#1-feature-goal","title":"1. Feature Goal","text":"<p>To provide a simple and convenient way for users to manage their guest Wi-Fi network directly from the Home Assistant web UI, without needing to log in to the Meraki dashboard. The primary focus will be on enabling/disabling the guest network, managing its password, and optionally configuring a custom, self-hosted splash page with email collection.</p>"},{"location":"design/guest_wifi/#2-ui-design-on-a-new-guest-wi-fi-page","title":"2. UI Design (on a new \"Guest Wi-Fi\" page)","text":"<p>The page will be divided into two main sections:</p> <p>**Section 1: Basic Guest Network Control</p> <ul> <li>Enable Guest Wi-Fi: A toggle switch to enable/disable the guest SSID.</li> <li>Guest Wi-Fi Password: A text input to view and change the password, with a save button.</li> </ul> <p>**Section 2: Custom Splash Page Configuration</p> <ul> <li>Enable Custom Splash Page: A main toggle switch for this feature.</li> <li>When enabled, the following options appear:</li> <li>Splash Page Content: A text area where you can enter a welcome message or terms of service for your splash page.</li> <li>Collect Email Addresses: A checkbox to enable a simple email sign-up form on the splash page.</li> <li>Splash Page URL: A read-only field showing the public URL where your splash page will be hosted (e.g., <code>http://&lt;your_ha_public_url&gt;/api/meraki_ha/splash/{network_id}</code>).</li> </ul> <p>Important Security Note: A clear warning message will be displayed here:</p> <p>\"Enabling this feature will automatically create a firewall rule (a 'walled garden' exception) to allow unauthenticated guest devices to access this Home Assistant URL. Please ensure your Home Assistant instance is securely configured.\"</p>"},{"location":"design/guest_wifi/#3-implementation-plan-instructions-for-a-continuing-agent","title":"3. Implementation Plan &amp; Instructions for a Continuing Agent","text":"<p>**Goal</p> <p>Implement the \"Guest Wi-Fi Management\" feature as described above.</p> <p>**Prerequisites</p> <ul> <li>Familiarity with creating Home Assistant <code>switch</code> and <code>text</code> entities.</li> <li>Knowledge of the Meraki API for managing SSIDs.</li> <li>Familiarity with React (functional components, hooks like <code>useState</code> and <code>useEffect</code>).</li> <li>Understanding of how to make API calls in JavaScript using <code>fetch</code>.</li> </ul> <p>**Step-by-Step Implementation Plan</p>"},{"location":"design/guest_wifi/#1-backend-core-entities-api","title":"**1. Backend: Core Entities &amp; API","text":"<ul> <li>Entities:</li> <li>Implement the <code>MerakiGuestWifiPasswordText</code> entity as previously described.</li> <li>Web Server (<code>web_server.py</code>):</li> <li>Public Splash Page Endpoint: Create a new, unauthenticated route like <code>/api/meraki_ha/splash/{network_id}</code>. This route will serve a modern-looking HTML page. The content of this page will be dynamically generated based on the user's settings (the custom content and whether the email form is enabled).</li> <li>Email Collection Endpoint: Create a new endpoint like <code>/api/meraki_ha/splash_signup</code> to handle the form submission from the splash page. This endpoint will save the collected email addresses (e.g., to a <code>.csv</code> file in your <code>config</code> directory).</li> <li>Configuration Endpoints: Create new API endpoints (<code>/api/guest_wifi/splash_settings</code>) for the frontend to get and set the splash page configuration (enabled, content, email collection setting).</li> </ul>"},{"location":"design/guest_wifi/#2-backend-meraki-api-interaction","title":"**2. Backend: Meraki API Interaction","text":"<ul> <li> <p>When the user enables the custom splash page, the integration will need to make a series of API calls:</p> </li> <li> <p>Update SSID Settings: Call <code>PUT /networks/{networkId}/wireless/ssids/{number}</code> to set:</p> </li> <li><code>splashPage</code> to <code>\"Click-through splash page\"</code>.</li> <li><code>splashUrl</code> to the public URL of the new splash page endpoint.</li> <li>Update Firewall Rules: Call <code>PUT /networks/{networkId}/wireless/ssids/{number}</code> to update the <code>walledGardenRanges</code>. The public URL of your Home Assistant instance must be added to this list to allow guest devices to access the splash page.</li> </ul>"},{"location":"design/guest_wifi/#3-frontend-ui-implementation","title":"**3. Frontend: UI Implementation","text":"<ul> <li>Create the new \"Guest Wi-Fi\" page (<code>GuestWifiPage.jsx</code>) as designed above.</li> <li>The page will fetch its state from the new backend endpoints.</li> <li>The \"Save\" buttons will post the configuration back to the backend.</li> </ul>"},{"location":"design/guest_wifi/#4-build-and-verify","title":"**4. Build and Verify","text":"<ul> <li>As before, this will involve building the frontend and using a Playwright script to test the new UI and its functionality.</li> </ul>"},{"location":"design/parental_controls/","title":"Updated Design and Implementation Plan: Parental Controls &amp; Content Filtering","text":""},{"location":"design/parental_controls/#1-product-vision-scope","title":"1. Product Vision &amp; Scope","text":"<p>The goal is to empower users with an intuitive and responsive interface to manage parental controls on their home network via Home Assistant, leveraging the power of their Meraki MX Security Appliance. This plan prioritizes simplicity and safety to ensure the integration is reliable and does not negatively impact existing network configurations.</p> <p>This plan will focus on two core features:</p> <ul> <li>Network-wide content filtering via policy selection.</li> <li>On-demand device-level internet blocking (\"time-out\").</li> </ul> <p>**2. Core Features &amp; User Stories</p> <ul> <li>Content Filtering Policy Selection: * User Story: As a parent, I want to quickly switch my network\u2019s content filtering policy from \"school\" to \"gaming\" to \"bedtime\" directly from Home Assistant, so I can easily manage my family's internet access throughout the day.</li> <li> <p>Implementation: A <code>select</code> entity will be exposed for each Meraki network, allowing the user to choose from a list of predefined content filtering policies from the Meraki dashboard.</p> </li> <li> <p>On-Demand Device Internet \"Time-Out\":</p> </li> <li>User Story: As a parent, I want to instantly disable internet access for my child's device, so I can enforce a \"time-out\" when they're not listening.</li> <li>Implementation: A <code>switch</code> entity will be created for each detected client device. Toggling this switch will create or remove a device-specific Layer 7 (L7) firewall rule, blocking all internet traffic for that client.</li> </ul> <p>**3. Technical Design</p>"},{"location":"design/parental_controls/#31-home-assistant-entities","title":"**3.1. Home Assistant Entities","text":"<ul> <li>Entity 1: Content Filtering <code>select</code> Entity</li> <li>Entity ID: <code>select.meraki_content_filtering_policy_&lt;network_name_slug&gt;</code></li> <li>Function: This entity will pull the list of available content filtering policies from the Meraki dashboard. The agent must handle the retrieval of these policy names, including the default categories (<code>Block all</code>, <code>Adult themes</code>, etc.) and any custom policies.</li> <li> <p>API Calls: * <code>GET /networks/{networkId}/appliance/contentFiltering</code> (for initial state)</p> <ul> <li><code>PUT /networks/{networkId}/appliance/contentFiltering</code> (for state change)</li> </ul> </li> <li> <p>Entity 2: Client <code>switch</code> Entity</p> </li> <li>Entity ID: <code>switch.meraki_client_internet_access_&lt;client_mac_address_slug&gt;</code></li> <li>Function: This entity's state will reflect the internet access status for a specific device. Toggling the switch will create or delete a specific L7 firewall rule for that device.</li> <li>API Calls:<ul> <li><code>GET /networks/{networkId}/clients</code> (to get a list of clients and their MAC/IP)</li> <li><code>GET /networks/{networkId}/appliance/firewall/l7FirewallRules</code> (to check for existing rules)</li> <li><code>PUT /networks/{networkId}/appliance/firewall/l7FirewallRules</code> (to add/remove rules)</li> </ul> </li> </ul>"},{"location":"design/parental_controls/#32-meraki-api-interaction","title":"**3.2. Meraki API Interaction","text":"<ul> <li>Content Filtering: The API endpoints are correctly identified. The agent should be aware that the <code>PUT</code> request to update content filtering requires the entire object, including the <code>allowedUrlPatterns</code> and <code>blockedUrlPatterns</code>. It should read the current state first, update only the policy, and then write the complete object back.</li> <li> <p>Client Firewall Rules: This is the most critical part of the implementation. The agent must:</p> </li> <li> <p>Use a unique comment to identify its rules. Suggestion: <code>{\"comment\": \"Managed by Home Assistant Meraki Parental Controls\"}</code>. This is essential to prevent conflicts with manually created rules.</p> </li> <li>When a switch is toggled on (to block), the agent will add a new L7 firewall rule with the specific client's IP address.</li> <li>Rule Type: Deny</li> <li>Protocol: Any</li> <li>Port: Any</li> <li>URL Pattern: <code>*</code></li> <li>Client IP: The IP of the device. The agent will need to get the IP address from the <code>/networks/{networkId}/clients</code> endpoint.</li> <li>When a switch is toggled off (to allow), the agent will find the rule with the unique comment and the matching client IP and remove it from the list of rules before sending the <code>PUT</code> request.</li> <li>Important: The Meraki API has an endpoint to get a client's IP address (<code>GET /networks/{networkId}/clients/{clientId}/status</code>). The agent should use this to get the IP, as the <code>/networks/{networkId}/clients</code> endpoint might not always have the most up-to-date IP address.</li> </ul>"},{"location":"design/parental_controls/#33-state-management-polling","title":"**3.3. State Management &amp; Polling","text":"<ul> <li>The integration must poll the Meraki API at a reasonable interval (e.g., every 3-5 minutes) to update the state of the Home Assistant entities.</li> <li>The <code>select</code> entity's state should reflect the current Meraki network policy.</li> <li>The <code>switch</code> entities' states should reflect the presence or absence of the corresponding L7 firewall rules. This ensures the Home Assistant UI stays in sync with the Meraki configuration, even if changes are made outside of Home Assistant.</li> </ul> <p>**4. Risks &amp; Mitigations</p> <ul> <li>Risk: Overwriting user-defined firewall rules.</li> <li> <p>Mitigation: The plan to use a unique comment is the correct approach. The agent must only modify rules that contain this specific comment. All other rules must be preserved.</p> </li> <li> <p>Risk: Meraki API rate limiting.</p> </li> <li> <p>Mitigation: The agent should implement a delay or a queue for multiple API calls (e.g., when a user rapidly toggles several switches). Polling intervals should be carefully considered to avoid hitting the API too frequently.</p> </li> <li> <p>Risk: The Meraki device loses connection or the API key is invalid.</p> </li> <li>Mitigation: The integration should use robust error handling. If an API call fails, the entity state should be set to <code>unavailable</code>, and an error message should be logged in Home Assistant.</li> </ul> <p>**5. Additional &amp; Optional Features</p> <p>Based on the capabilities of Meraki devices, here are a few more advanced features that would significantly enhance the user experience and create a more robust parental controls solution.</p> <ul> <li>Scheduled Access (Time-based Rules):</li> <li>Concept: Instead of just an on/off switch, allow users to set schedules for internet access. This could be exposed as a Home Assistant schedule helper entity.</li> <li>How it works: The integration would manage L7 firewall rules that are only active during specific times (e.g., blocking social media from 9 PM to 7 AM). The Meraki API supports time-of-day-based rules.</li> <li> <p>Value: Automates a common use case for parental controls, reducing the need for manual intervention.</p> </li> <li> <p>Application &amp; URL Blocking:</p> </li> <li>Concept: Provide a user interface to block specific applications (e.g., \"YouTube,\" \"Fortnite\") or custom URLs for a device.</li> <li>How it works: Meraki's L7 firewall rules support blocking by application, application category, and URL. The integration could expose a new entity or a service call in Home Assistant for this.</li> <li> <p>Value: Offers more granular control than simple on/off. Parents could block specific games or websites without disabling all internet access.</p> </li> <li> <p>Client Information &amp; Monitoring:</p> </li> <li>Concept: Expose more information about client devices as sensors in Home Assistant.</li> <li>How it works: Create sensors for data usage (downlink/uplink), current IP address, and connected wireless network name/SSID.</li> <li>Value: Provides a single-pane-of-glass view for monitoring network activity, which is a key part of parental controls. This leverages Meraki's powerful network visibility features.</li> </ul>"},{"location":"ideas/refactor_webui/","title":"Refactor webui","text":"<p>**AI Agent Instructions</p> <p>Persona: A senior product manager with a deep understanding of user experience and system architecture.</p> <p>Objective: The primary objective is to transform the integration's web UI from a simple static view into a dynamic, informative dashboard. The goal is to surface a complete, real-time overview of the Meraki network's status and health. The UI should preemptively answer a user's questions by displaying critical information\u2014such as device discovery, entity status, and potential issues\u2014that currently resides in backend logs.</p> <p>Core Principles to Guide Implementation:</p> <ol> <li>Dashboard First: The initial view must be a high-level dashboard. It should provide a quick, at-a-glance summary of the entire organization, including key counts (e.g., number of wireless devices, switches, cameras) and any critical alerts.</li> <li>Drill-Down Capability: The user must be able to click on any summary metric or a specific device to access a detailed view. This detailed view will contain all relevant information for that specific device or entity, including its associated sensors, switches, and any logged status messages.</li> <li>Proactive Communication: The UI should move beyond showing what is and begin explaining why. For example, instead of just showing that an RTSP stream is unavailable, it should display the specific reason logged in the backend. This is the core value-add for the user.</li> <li>Modern UI/UX: The interface must be a modern web application. It should be fully responsive, work seamlessly on both mobile and desktop, and automatically adapt to the user's browser theme (light/dark mode). All components should be reusable and adhere to a clean, consistent design language.</li> <li>State-Driven Interface: The UI should not poll the API directly. It must be a passive consumer of a live data feed from the Home Assistant backend. This will ensure a performant and efficient user experience.</li> </ol> <p>**Architecture &amp; Design Instructions</p> <p>The UI will be a single-page application (SPA) built using React for its component-based architecture and state management capabilities, with Tailwind CSS for a utility-first approach to styling.</p> <ul> <li>Data Model: The Home Assistant integration will expose a dedicated WebSocket API endpoint that serves a centralized data payload. This payload will contain counts for all device types, a list of all discovered entities with their properties (device info, type, status), and a new field for <code>status_messages</code> on each device. This new field will hold the valuable, human-readable information from the logs.</li> <li>Component Hierarchy:</li> <li><code>App.tsx</code> (Main Component): Manages the primary application state (e.g., <code>loading</code>, <code>data</code>, <code>activeView</code>). It establishes the WebSocket connection and handles client-side routing.</li> <li><code>Dashboard.tsx</code>: Displays the high-level metrics using <code>StatusCard</code> components and a summary table of devices.</li> <li><code>DeviceView.tsx</code>: Displays detailed information for a single device, including its metadata and a list of all associated entities.</li> <li><code>StatusCard.tsx</code>: A reusable component to show a single metric with a title, a value, and an icon. This promotes a consistent look and feel across the dashboard.</li> <li><code>DeviceTable.tsx</code>: A searchable, sortable component to list all discovered Meraki devices.</li> <li>Styling: Tailwind's <code>dark:</code> modifier will be used exclusively for dark mode. All styling will be done with Tailwind classes to ensure full responsiveness and a clean, modern aesthetic. The font should be <code>Inter</code> for clarity and a modern feel.</li> </ul> <p>**Detailed Implementation Plan</p> <p>This plan is a step-by-step guide for an AI agent to build the new UI from scratch.</p> <p>Phase 1: Backend Data &amp; API</p> <ol> <li>Create WebSocket Endpoint:</li> <li>Create a new file, <code>custom_components/meraki_ha/api/websocket.py</code>.</li> <li>Define a WebSocket handler that, when a connection is established, immediately sends a complete snapshot of the integration's data from <code>hass.data[DOMAIN][config_entry.entry_id]</code>.</li> <li> <p>Implement a state change listener (e.g., using a Home Assistant <code>callback</code>) that pushes updates to all connected WebSocket clients whenever the coordinator's data changes. This ensures the UI is always in sync.</p> </li> <li> <p>Enrich Data with Status Messages:</p> </li> <li>Modify the Meraki data coordinator to store a new <code>status_messages</code> list for each device in its data payload.</li> <li>Whenever an entity or handler logs a significant event (e.g., \"Could not retrieve stream...\"), instead of just logging a message, it should also add a formatted string to this new <code>status_messages</code> list for the relevant device.</li> </ol> <p>Phase 2: Frontend Foundation (React)</p> <ol> <li>Set up the React App:</li> <li>Create a React app in a new folder: <code>custom_components/meraki_ha/www</code>.</li> <li>Remove all boilerplate code and create a single <code>App.tsx</code> component.</li> <li>Connect to Backend:</li> <li>In <code>App.tsx</code>, use a <code>useState</code> hook for <code>data</code>, <code>loading</code>, and <code>error</code>.</li> <li>In a <code>useEffect</code> hook, establish a WebSocket connection to the Home Assistant endpoint.</li> <li>On a successful connection and a received message, update the <code>data</code> state. Implement a basic loading indicator (e.g., a spinner or text) while <code>loading</code> is true.</li> <li>Implement Routing:</li> <li>Create a simple state-based routing system within <code>App.tsx</code> using a state variable like <code>activeView</code>.</li> <li>The <code>App.tsx</code> component will conditionally render either the <code>Dashboard</code> component or the <code>DeviceView</code> component based on the <code>activeView</code> state.</li> </ol> <p>Phase 3: Dashboard &amp; Core Components</p> <ol> <li>Build <code>StatusCard.tsx</code>:</li> <li>Create this reusable component. It will accept props like <code>title</code>, <code>value</code>, <code>icon</code>, and a <code>onClick</code> handler.</li> <li>Apply Tailwind classes for styling, including responsive padding and margins. Use the <code>dark:</code> prefix for dark mode styles.</li> <li>Build <code>Dashboard.tsx</code>:</li> <li>Use Tailwind's <code>grid-cols-1 md:grid-cols-2 lg:grid-cols-4</code> to create a responsive card layout.</li> <li>Render an instance of <code>StatusCard</code> for each key metric: \"Total Devices,\" \"Wireless APs,\" \"Switches,\" \"Cameras,\" and \"Virtual SSIDs.\" The values for these cards will come from the <code>data</code> received from the WebSocket.</li> <li>Build <code>DeviceTable.tsx</code>:</li> <li>Create a component that renders a table with columns for Device Name, Model, and Status.</li> <li>Add a search bar at the top to filter the table by device name or serial.</li> <li>Add a <code>onClick</code> handler to each table row that sets the <code>activeView</code> state in the parent <code>App</code> component to show the device details.</li> </ol> <p>Phase 4: Device Details &amp; Final Touches</p> <ol> <li>Build <code>DeviceView.tsx</code>:</li> <li>This component will receive the selected device's data as a prop.</li> <li>Display key information like <code>name</code>, <code>model</code>, <code>serial</code>, and <code>firmware</code> in a prominent card at the top.</li> <li>Display the new <code>status_messages</code> list from the device's data payload. Use a unique style (e.g., a red border for warnings) to make them stand out.</li> <li>Create a list or table of all <code>entities</code> belonging to this device, clearly showing their name, type, and current state.</li> <li>Implement Dark Mode:</li> <li>Review all React components and their styling.</li> <li>For any color or background, ensure you have a <code>dark:</code> prefix class defined (e.g., <code>bg-white dark:bg-gray-800</code>). The browser will handle the rest.</li> <li>Add Final Polish:</li> <li>Implement smooth transitions for component changes.</li> <li>Add an icon for each card in the dashboard.</li> <li>Ensure the overall layout is centered and has adequate spacing.</li> </ol> <p>This implementation plan, guided by the product principles of being proactive and intuitive, will result in a significantly more useful and polished web UI for the Meraki Home Assistant integration.</p>"},{"location":"internal/","title":"Internal Documentation","text":"<p>This directory contains the internal documentation for the Meraki Home Assistant integration. It is intended for developers and contributors.</p>"},{"location":"internal/#sections","title":"Sections","text":"<ul> <li>Architecture</li> <li>Testing</li> </ul>"},{"location":"internal/architecture/","title":"Architecture Overview for <code>meraki-ha</code>","text":""},{"location":"internal/architecture/#1-executive-summary","title":"1. Executive Summary","text":"<p>This document provides an overview of the architecture for the <code>meraki-ha</code> custom component. The integration is designed for performance and scalability, with a focus on efficient data fetching, centralized state management, and modular design.</p> <p>The key architectural pillars are:</p> <ul> <li>Centralized Data Fetching: A single data coordinator (<code>MerakiDataCoordinator</code>) is responsible for all API communication, eliminating redundant API calls and ensuring data consistency.</li> <li>Optimized API Usage: The API client (<code>MerakiAPIClient</code>) leverages concurrent API calls using <code>asyncio.gather</code> to reduce latency and improve responsiveness.</li> <li>Efficient State Management: The <code>MerakiDataCoordinator</code> creates lookup tables for devices, networks, and SSIDs after each data fetch. This provides entities with fast, O(1) access to their data, avoiding slow, iterative lookups.</li> <li>Modular Design: The codebase is broken down into smaller, more focused modules. The API client uses a facade pattern, delegating calls to endpoint-specific handlers. Utility functions and sensor setup logic have also been modularized.</li> </ul>"},{"location":"internal/architecture/#2-core-components","title":"2. Core Components","text":"<p>**2.1. <code>MerakiDataCoordinator</code></p> <p>The heart of the integration is the <code>MerakiDataCoordinator</code>, located in <code>custom_components/meraki_ha/core/coordinators/meraki_data_coordinator.py</code>.</p> <ul> <li>Responsibilities:</li> <li>Manages a single, periodic refresh of all data from the Meraki API via the <code>MerakiAPIClient</code>.</li> <li>Holds the complete state of the integration in its <code>data</code> attribute.</li> <li>After fetching data, it creates several lookup tables for efficient data retrieval by entities:<ul> <li><code>devices_by_serial</code>: A dictionary mapping device serial numbers to device data.</li> <li><code>networks_by_id</code>: A dictionary mapping network IDs to network data.</li> <li><code>ssids_by_network_and_number</code>: A dictionary mapping a <code>(network_id, ssid_number)</code> tuple to SSID data.</li> </ul> </li> <li>Entity Interaction: Entities in Home Assistant are subclasses of <code>CoordinatorEntity</code> and are linked to the <code>MerakiDataCoordinator</code>. They should not fetch their own data. Instead, they access the coordinator's <code>data</code> or use the efficient <code>get_device()</code>, <code>get_network()</code>, and <code>get_ssid()</code> methods to retrieve their state. When the coordinator updates its data, it notifies all listening entities, which then update their state via their <code>_handle_coordinator_update()</code> method.</li> </ul> <p>**2.2. <code>MerakiAPIClient</code></p> <p>The <code>MerakiAPIClient</code>, located in <code>custom_components/meraki_ha/core/api/client.py</code>, is responsible for all communication with the Meraki Dashboard API.</p> <ul> <li>Design: It acts as a facade, providing a single entry point for fetching all data (<code>get_all_data</code>). It delegates the actual API calls to smaller, endpoint-specific handler classes located in <code>custom_components/meraki_ha/core/api/endpoints/</code>.</li> <li>Concurrency: The client uses <code>asyncio.gather</code> and a semaphore to fetch data from multiple API endpoints concurrently, significantly reducing the total time spent waiting for I/O. This makes the integration feel much more responsive, especially during startup.</li> </ul> <p>**2.3. Entity and Sensor Setup</p> <ul> <li><code>setup_helpers.py</code>: The logic for creating all sensor entities is centralized in <code>custom_components/meraki_ha/sensor/setup_helpers.py</code>. This file was refactored from a single large function into several smaller, more manageable helper functions, each responsible for a specific category of sensor (e.g., <code>_setup_device_sensors</code>, <code>_setup_network_sensors</code>).</li> <li><code>sensor_registry.py</code>: To ensure type safety and avoid <code>mypy</code> errors, the integration uses a sensor registry (<code>custom_components/meraki_ha/sensor_registry.py</code>). This registry explicitly defines which sensor classes should be created for each Meraki device type and what their constructor arguments are. This avoids the need for dynamic, untyped introspection.</li> </ul>"},{"location":"internal/architecture/#3-error-handling-and-resiliency","title":"3. Error Handling and Resiliency","text":"<p>The integration is designed to be resilient to transient API errors and network issues, providing a stable user experience.</p> <p>**3.1. Stale Data on Failure</p> <p>If the <code>MerakiDataCoordinator</code> fails to fetch an update from the Meraki API, it does not immediately mark all entities as unavailable. Instead, it checks the timestamp of the last successful update. If the last successful data is within a configurable threshold (defaulting to 30 minutes), the coordinator will log a warning but continue to provide the existing \"stale\" data to all entities. This makes the integration resilient to brief network or API outages, preventing the user's dashboard from going blank due to a temporary glitch. This feature can be configured in the integration's options.</p> <p>**3.2. Partial Data Merging</p> <p>The <code>MerakiAPIClient</code> fetches data from multiple endpoints concurrently. If one of these sub-requests fails, the integration does not discard all the data from the successful requests. Instead, it will use the data from the last successful coordinator run for the specific slice of data that failed. For example, if fetching VLAN information fails but device statuses succeed, the VLAN sensors will continue to show their previous state, while the device status sensors will show the latest information. This prevents a single, non-critical API failure from causing an entire category of sensors to become unavailable.</p> <p>**3.3. Persistent Caching</p> <p>To improve startup times for Home Assistant, the integration uses a persistent disk cache (<code>diskcache</code>). The results of the <code>get_all_data</code> API call are cached on disk with a short TTL (2 minutes). When Home Assistant restarts, the integration can load the cached data almost instantly, making entities available right away while a fresh API call is made in the background.</p>"},{"location":"internal/architecture/#4-webhook-implementation-status","title":"4. Webhook Implementation Status","text":"<p>The integration now has a functional webhook implementation for real-time updates. The system can register a webhook with the Meraki API and handle incoming alerts. Currently, it processes alerts for \"APs went down\" and \"Client connectivity changed\" to provide near real-time status updates for device and client entities. The framework is in place to easily add handlers for more alert types in the future.</p>"},{"location":"internal/architecture/appliance/","title":"AI Agent Instructions","text":"<p>Your task is to refactor the <code>meraki_ha</code> integration to correctly retrieve and represent a device's on/off state and other controls for Meraki MX and GX appliances. The current methods are likely out of sync with the new architecture. Follow the updated design plan to ensure the refactored code is modular, testable, and robust.</p> <ol> <li>Identify and use correct API endpoints: The Meraki API has specific endpoints for controlling device state. You need to identify the correct API calls for toggling a device on/off, as well as checking its status.</li> <li>Integrate with the <code>MerakiRepository</code>: All API calls must go through the repository, which handles caching, rate-limiting, and state management. You must not call the API client directly.</li> <li>Create a dedicated control service: To avoid deep nesting and large files, create a new service specifically for handling device control logic. This service will contain methods like <code>async_reboot_device</code> or <code>async_set_power_state</code>.</li> <li>Update <code>DeviceHandlers</code>: The handlers for MX and GX devices must be refactored to use the new service for any actions (e.g., reboot). They will be responsible for creating the corresponding Home Assistant switch or button entities.</li> <li>Write thorough tests: For each new method and class, write unit tests that mock the repository and confirm the logic functions as expected. This will prevent regressions.</li> </ol>"},{"location":"internal/architecture/appliance/#refactor-plan-for-mxgx-device-controls","title":"Refactor Plan for MX/GX Device Controls","text":"<p>This plan focuses on making device controls stateless and declarative by centralizing the action logic in a dedicated service that the device handlers can call.</p> <p>**Phase 1: API and Repository Updates</p> <ol> <li>Add <code>rebootDevice</code> to <code>MerakiApiClient</code>:</li> <li> <p>Add a new asynchronous method, <code>async_reboot_device(serial)</code>, that calls the Meraki API's <code>rebootDevice</code> endpoint. This method will send the command to the Meraki cloud.</p> </li> <li> <p>Add <code>reboot_device</code> to <code>MerakiRepository</code>:</p> </li> <li>Create a new method, <code>async_reboot_device(serial)</code>, in the <code>MerakiRepository</code>.</li> <li>This method will accept the device serial and call the <code>MerakiApiClient</code>. It will handle any errors, logging them but not raising exceptions that would crash the integration.</li> <li>Because this is a write action, it should not be cached.</li> </ol> <p>**Phase 2: Create a Dedicated Control Service</p> <ol> <li>Develop <code>DeviceControlService</code> (<code>meraki_ha/services/device_control_service.py</code>):</li> <li>Create a new class, <code>DeviceControlService</code>, that is injected with the <code>MerakiRepository</code>.</li> <li>This service will contain methods for device actions, such as:<ul> <li><code>async_reboot(serial)</code>: A method that calls the repository's <code>async_reboot_device</code> method.</li> </ul> </li> <li>The separation of this logic into a service keeps the <code>DeviceHandlers</code> thin and focused on entity creation.</li> </ol> <p>**Phase 3: Update Device Handlers and Entities</p> <ol> <li>Refactor <code>MXHandler</code> and <code>GXHandler</code>:</li> <li>Update the handlers to accept the <code>DeviceControlService</code> via Dependency Injection.</li> <li>Within the handler's entity creation logic, create new <code>homeassistant.components.button.ButtonEntity</code> or <code>switch</code> entities as appropriate.</li> <li>The <code>async_press</code> method of the button entity or the <code>async_turn_on</code>/<code>async_turn_off</code> methods of the switch entity must call the corresponding method on the injected <code>DeviceControlService</code>. For example, the button's <code>async_press</code> will call <code>await self._control_service.async_reboot(self.device_serial)</code>.</li> </ol> <p>**Phase 4: Testing and Cleanup</p> <ol> <li>Write Focused Unit Tests:</li> <li>Test the <code>DeviceControlService</code> by injecting a mock <code>MerakiRepository</code> and asserting that the <code>async_reboot</code> method is called correctly.</li> <li>Test the <code>MXHandler</code> and <code>GXHandler</code> to ensure they correctly create the button or switch entities. Use a mock control service and verify that the entity's action method calls the service as expected.</li> <li>Remove Old Code:</li> <li>Delete any old, direct API calls for device control that may still exist in the <code>NetworkHub</code> or <code>DeviceHandlers</code>. Ensure all control actions are routed through the new service.</li> </ol>"},{"location":"internal/architecture/camera_component/","title":"Camera component","text":"<p>**AI Agent Instructions</p> <p>Persona: Meticulous and knowledgeable Python engineer with a deep understanding of Home Assistant\u2019s architecture.</p> <p>Objective: The primary goal is to restore the core functionality of the Home Assistant Camera entity for Meraki MV devices, which was inadvertently removed during a previous refactor. This task requires precision and adherence to the established architectural pattern.</p> <p>Task Requirements:</p> <ol> <li>Reintroduce the Camera Entity: Locate and modify the <code>MVHandler</code> class to re-integrate the <code>MerakiCamera</code> entity as a discovered component.</li> <li>Maintain Service-Oriented Design: Ensure the camera entity is correctly instantiated with the necessary dependency, <code>CameraService</code>, which provides the underlying logic for fetching video streams and snapshots. The <code>MVHandler</code> should receive <code>CameraService</code> as a dependency in its <code>__init__</code> method.</li> <li>Ensure Correct Imports: Verify all required classes (<code>MerakiCamera</code>, <code>CameraService</code>, <code>MerakiDataCoordinator</code>, etc.) are correctly imported in the relevant files to prevent <code>ImportError</code> exceptions.</li> <li>Preserve Existing Functionality: The refactor must not negatively impact any other entities handled by <code>MVHandler</code>, such as motion sensors or analytics counts. All existing functionality must remain intact.</li> <li>Robustness and Error Handling: The implementation must be robust, with clear logging messages to assist with future debugging. The code should handle potential API call failures gracefully.</li> <li>Comprehensive Testing: The agent must update existing unit tests for the <code>MVHandler</code> to specifically assert that a <code>MerakiCamera</code> entity is created and returned by the <code>discover_entities</code> method.</li> </ol> <p>**Implementation Plan</p> <p>The implementation will follow a three-phase approach to ensure a controlled and verifiable re-integration of the camera functionality.</p> <p>Phase 1: Code Re-integration</p> <ol> <li>Update the <code>MVHandler</code>:</li> <li>Open <code>custom_components/meraki_ha/discovery/handlers/mv.py</code>.</li> <li>Add the necessary import for the <code>MerakiCamera</code> class at the top of the file:      <code>python      from ...camera import MerakiCamera</code></li> <li>Within the <code>MVHandler</code>'s <code>__init__</code> method, ensure that <code>camera_service</code> is correctly passed and stored as an attribute (<code>self._camera_service</code>).</li> <li>Inside the <code>discover_entities</code> method, add the code to instantiate and append the <code>MerakiCamera</code> entity to the list of entities to be returned. This should be the first entity appended, as it is the primary entity for a camera device.      <code>python      # Always create the base camera entity      entities.append(          MerakiCamera(              self._coordinator,              self.device,              self._camera_service,          )      )</code></li> <li>Review the <code>DeviceDiscoveryService</code>:</li> <li>Open <code>custom_components/meraki_ha/discovery/service.py</code>.</li> <li>Verify that the <code>MVHandler</code> is being instantiated with the <code>camera_service</code> in the <code>discover_entities</code> method. This step is critical to ensure the <code>MVHandler</code> has the dependency it needs to create the camera entity.</li> </ol> <p>Phase 2: Test Suite Refinement</p> <ol> <li>Update the <code>MVHandler</code> Tests:</li> <li>Open <code>tests/discovery/handlers/test_mv.py</code>.</li> <li>Modify the <code>test_mv_handler_all_features</code> test case.</li> <li>Add a new assertion to the test to explicitly check for the presence of a <code>MerakiCamera</code> instance in the list of returned entities.      <code>python      assert any(isinstance(e, MerakiCamera) for e in entities)</code></li> <li>Ensure all other existing test cases are updated to also include this assertion, as a <code>MerakiCamera</code> entity should now always be discovered for an MV device.</li> </ol> <p>Phase 3: Validation and Finalization</p> <ol> <li>Run All Tests: Execute the entire test suite to confirm that all existing and new tests pass successfully, especially those related to the <code>MVHandler</code>.</li> <li>Manual Verification: Provide instructions for manual testing within Home Assistant. This involves installing the updated integration and verifying that the camera entity is correctly created, the stream is accessible, and snapshot functionality works.</li> <li>Code Cleanup: Once validated, remove any temporary or legacy code from the refactor and finalize the file with clear comments and docstrings.</li> </ol>"},{"location":"internal/architecture/cameras/","title":"Cameras","text":"<p>**AI Agent Instructions</p> <p>Your task is to refactor the Meraki MV camera integration to properly handle various camera models and their unique features. This requires a granular, type-aware approach that goes beyond basic video streams. The goal is to dynamically expose all supported sensors and controls for each specific camera model.</p> <ol> <li>Refactor <code>MerakiRepository</code> for Camera-Specific Endpoints: Identify and implement the necessary API endpoints to retrieve a camera's specific capabilities. This may include endpoints for <code>getDeviceCameraAnalyticsOverview</code>, <code>getDeviceCameraAnalyticsZones</code>, and <code>getDeviceCameraVideoLink</code>.</li> <li>Modularize Camera-Specific Logic: Create a new, dedicated <code>CameraService</code> to handle all camera-related functions. This service will use the repository to fetch data and expose methods that are agnostic of the camera model, while the underlying logic handles the model-specific differences.</li> <li>Implement a Type-Aware <code>MVHandler</code>: The <code>MVHandler</code> must be refactored to be model-aware. During discovery, it should query the device for its model type and then conditionally create entities based on that model's supported features.</li> <li>Enforce Strict Code Separation: As instructed previously, break down complex logic into small, single-purpose functions. No file should exceed 300 lines, and indentation should be limited to a maximum of three levels.</li> </ol> <p>**Camera Entity Requirements</p> <p>To ensure a consistent and feature-rich experience, all Meraki camera devices must have the following entities created by the <code>MVHandler</code>.</p> <ul> <li><code>MerakiCamera</code>: The main <code>camera</code> entity that displays the RTSP video stream.</li> <li><code>MerakiMotionSensor</code>: A <code>binary_sensor</code> that indicates motion.</li> <li><code>MerakiSnapshotButton</code>: A <code>button</code> entity to trigger a snapshot.</li> <li><code>MerakiRtspUrlSensor</code>: A <code>sensor</code> that displays the current RTSP stream URL.</li> <li><code>RTSPStreamSwitch</code>: A <code>switch</code> entity to enable or disable the RTSP stream.</li> <li><code>AnalyticsSwitch</code>: A <code>switch</code> entity to enable or disable camera analytics.</li> </ul> <p>Conditional Entities:</p> <ul> <li><code>MerakiPersonCountSensor</code>: A <code>sensor</code> for the person count, created only if the camera model supports person detection.</li> <li><code>MerakiVehicleCountSensor</code>: A <code>sensor</code> for the vehicle count, created only if the camera model supports vehicle detection.</li> </ul> <p>Important Implementation Details:</p> <ul> <li>All camera-related entities must have a <code>device_info</code> property that correctly links them to the parent Meraki camera device in Home Assistant.</li> <li>The on/off control for the RTSP stream must be handled by the <code>RTSPStreamSwitch</code> entity, not by methods on the <code>MerakiCamera</code> entity itself.</li> </ul> <p>**Refactor Plan for Meraki MV Cameras</p> <p>This plan builds on the existing architecture to implement a dynamic and feature-rich integration for Meraki MV cameras, properly handling the unique capabilities of each model.</p>"},{"location":"internal/architecture/cameras/#phase-1-api-and-repository-updates","title":"**Phase 1: API and Repository Updates","text":"<ol> <li>Enhance <code>MerakiApiClient</code>:</li> <li>Add new methods to retrieve camera analytics data (<code>get_device_camera_analytics</code>, <code>get_network_camera_analytics_history</code>). These endpoints allow access to rich data like object counts (people/vehicles) and motion history.</li> <li> <p>Add a method to get live video stream URLs (<code>get_device_camera_video_link</code>), which is the correct way to get the RTSP stream.</p> </li> <li> <p>Add <code>CameraRepository</code> Methods:</p> </li> <li>Create a new <code>CameraRepository</code> or expand the existing <code>MerakiRepository</code> to include camera-specific methods. This repository layer will abstract the different API calls based on a camera's model and capabilities.</li> <li>Methods should include <code>get_camera_features(serial)</code> to retrieve a camera's model-specific capabilities, <code>get_analytics_data(serial)</code> to fetch object detection and motion data, and <code>get_video_url(serial)</code> for the stream.</li> </ol>"},{"location":"internal/architecture/cameras/#phase-2-create-a-dedicated-camera-service","title":"**Phase 2: Create a Dedicated Camera Service","text":"<ol> <li>Develop <code>CameraService</code> (<code>meraki_ha/services/camera_service.py</code>):</li> <li>This new service will be injected with the <code>MerakiRepository</code>.</li> <li>It will contain methods like <code>get_supported_analytics(serial)</code> that query the repository and return a list of features (e.g., <code>[\"person_detection\", \"vehicle_detection\"]</code>).</li> <li>Other methods will retrieve the actual analytics data and the video stream URL. The <code>CameraService</code>'s job is to shield the handlers from the complexities of the repository's API calls.</li> </ol>"},{"location":"internal/architecture/cameras/#phase-3-dynamic-entity-creation-with-mvhandler","title":"**Phase 3: Dynamic Entity Creation with <code>MVHandler</code>","text":"<ol> <li>Refactor <code>MVHandler</code>:</li> <li>Update the <code>MVHandler</code> to be type-aware. When it's created, it should get the device's model and query the <code>CameraService</code> for supported features.</li> <li> <p>The handler will then conditionally create Home Assistant entities based on the returned feature list.</p> <ul> <li>Camera Entity: Always create a base camera entity for the video stream. The stream URL will come from the <code>CameraService</code>.</li> <li>Sensor Entities: If the <code>CameraService</code> reports \"person_detection\" is supported, create a <code>person_count</code> sensor. If it supports \"vehicle_detection,\" create a <code>vehicle_count</code> sensor.</li> <li>Binary Sensor Entities: Create motion detection binary sensors based on motion history data from the <code>CameraService</code>.</li> <li>Button Entities: For models that support snapshots, create a \"Take Snapshot\" button that calls the snapshot API endpoint via the <code>CameraService</code>.</li> </ul> </li> <li> <p>Update <code>config_flow</code>:</p> </li> <li>Ensure the <code>CameraService</code> is instantiated and injected into the <code>MVHandler</code>.</li> </ol>"},{"location":"internal/architecture/cameras/#phase-4-testing-and-cleanup","title":"**Phase 4: Testing and Cleanup","text":"<ol> <li>Create Model-Specific Mock Data: When testing, use mock API responses that represent different camera models (e.g., one mock for an MV12, another for an MV93 with 360\u00b0 view and analytics). This will allow you to test that the <code>MVHandler</code> correctly creates the right entities for each model.</li> <li>Remove Legacy Code: Delete any old code that handles MV cameras in a monolithic or non-modular way, ensuring all new logic is routed through the repository and the new <code>CameraService</code>.</li> </ol>"},{"location":"internal/architecture/client_count/","title":"Client count","text":"<p>**AI Agent Instructions</p> <p>The connected client counts are incorrect because the existing implementation likely uses a simple API endpoint that provides a snapshot of connected clients at a single point in time, which can quickly become outdated. It may also not correctly aggregate data from multiple devices or networks. The fix involves using a different set of Meraki API endpoints that are designed for monitoring client data.</p> <p>Your task is to refactor how client counts are retrieved, ensuring the data is correct and properly aggregated for all relevant device types.</p> <ol> <li>Strictly use a more reliable API endpoint: The API provides specific endpoints for retrieving client count history and details. The most reliable way to get an accurate count is to use the <code>getNetworkWirelessClientCountHistory</code> endpoint or similar ones that provide aggregated data. Avoid using endpoints that simply list clients, as they often don't provide a real-time total.</li> <li>Modularize the count logic: Create a dedicated service or module specifically for handling client count logic. This will prevent the <code>NetworkHub</code> from becoming too complex.</li> <li>Aggregate data correctly: The logic must correctly handle data from different sources (MX, MR, VLANs, SSIDs) and sum them up to get a correct total.</li> </ol> <p>**Implementation Plan</p> <p>This plan builds on the existing modular architecture, adding a new service layer dedicated to client count collection and aggregation.</p>"},{"location":"internal/architecture/client_count/#phase-1-api-client-and-repository-updates","title":"**Phase 1: API Client and Repository Updates","text":"<ol> <li>Add new endpoints to <code>MerakiApiClient</code>:</li> <li>Add a new method, <code>get_network_wireless_client_count_history(network_id, **kwargs)</code>, that calls the Meraki API's <code>/networks/{networkId}/wireless/clientCountHistory</code> endpoint. This endpoint can filter by device serial, SSID, or other parameters.</li> <li> <p>Add other relevant endpoints for getting client lists or stats from specific devices (e.g., <code>get_device_clients</code> for individual devices) if needed for more granular data.</p> </li> <li> <p>Add new methods to <code>MerakiRepository</code>:</p> </li> <li>Create a <code>get_client_counts_for_network(network_id)</code> method in the repository.</li> <li>This method will use the newly added API client method to fetch client count data. It should handle the API call, parse the response, and cache the result according to a short-term TTL (e.g., 5-10 minutes) since client counts are dynamic.</li> <li>Add a similar method for getting device-specific client counts, if required.</li> </ol>"},{"location":"internal/architecture/client_count/#phase-2-create-a-client-count-service","title":"**Phase 2: Create a Client Count Service","text":"<ol> <li>Develop <code>ClientCountService</code> (<code>meraki_ha/services/client_count_service.py</code>):</li> <li>Create a new class that is injected with the <code>MerakiRepository</code>.</li> <li>This service will have a primary method, <code>get_aggregated_counts(network_id)</code>.</li> <li>This method will call the repository to get the latest client count data.</li> <li>It will then aggregate this data. The aggregation logic will vary based on the desired sensor type:<ul> <li>Network-wide count: Simply sum up the total clients from the API response for the entire network.</li> <li>Per-device count (e.g., for an MR or MX): The service will need to filter the API response by device serial number or use a separate API endpoint to get a device-specific client list.</li> <li>Per-VLAN/SSID count: The service must use the correct API parameters to filter the client count data by SSID number or VLAN and return that specific count.</li> </ul> </li> </ol>"},{"location":"internal/architecture/client_count/#phase-3-integration-and-entity-refinement","title":"**Phase 3: Integration and Entity Refinement","text":"<ol> <li>Update <code>NetworkHub</code>:</li> <li>Inject the <code>ClientCountService</code>: The <code>NetworkHub</code> should be updated to accept an instance of the <code>ClientCountService</code> in its constructor.</li> <li> <p>Call the service in <code>_async_update_data</code>: During the data update, the hub will call the <code>get_aggregated_counts</code> method from the injected service.</p> </li> <li> <p>Update <code>DeviceHandlers</code>:</p> </li> <li>Refactor count sensor creation: Within the <code>MRHandler</code> and <code>MXHandler</code> classes, update the logic for creating the client count sensors.</li> <li>The sensor's value should now come from the data returned by the <code>ClientCountService</code>, ensuring it is the correct, aggregated value.</li> </ol>"},{"location":"internal/architecture/client_count/#phase-4-testing-and-cleanup","title":"**Phase 4: Testing and Cleanup","text":"<ol> <li>Create new unit tests:</li> <li>Write new tests for the <code>MerakiRepository</code> methods that fetch client counts, ensuring they correctly handle API responses.</li> <li>Write unit tests for the <code>ClientCountService</code> to verify that it correctly aggregates data from various mock API responses.</li> <li> <p>Test the <code>NetworkHub</code> to ensure it correctly calls the <code>ClientCountService</code> and updates the entities.</p> </li> <li> <p>Remove old logic:</p> </li> <li>Delete any old, incorrect logic for counting clients from the <code>NetworkHub</code> or <code>DeviceHandlers</code>.</li> <li>Ensure no part of the code relies on endpoints that don't provide accurate or real-time counts.</li> </ol>"},{"location":"internal/architecture/development_setup/","title":"System Requirements for CI/CD, Build, and Versioning","text":"<p>This document outlines the requirements for setting up a CI/CD, build, and versioning system based on the practices of the <code>meraki-homeassistant</code> project.</p>"},{"location":"internal/architecture/development_setup/#1-development-environment","title":"1. Development Environment","text":"<p>The project requires both Python and Node.js for development and automation.</p> <ul> <li>Python:</li> <li>Version: 3.9 or higher.</li> <li>Dependencies are managed with <code>pip</code>.</li> <li>Application dependencies are listed in <code>requirements.txt</code>.</li> <li>Development dependencies are listed in <code>requirements_dev.txt</code>.</li> <li>Node.js:</li> <li>Version: 18 or higher.</li> <li>Dependencies are managed with <code>npm</code>.</li> <li>Development dependencies are listed in <code>package.json</code>.</li> </ul>"},{"location":"internal/architecture/development_setup/#2-git-hooks","title":"2. Git Hooks","text":"<p>The project uses the <code>pre-commit</code> framework to enforce code quality and consistency before code is committed.</p> <ul> <li>Setup: Developers must install <code>pre-commit</code> and run <code>pre-commit install</code> to set up the Git hooks locally.</li> <li>Configuration: The hooks are defined in the <code>.pre-commit-config.yaml</code> file.</li> <li>Required Hooks:</li> <li><code>pre-commit-hooks</code>: For basic checks like merge conflicts, JSON/TOML syntax, and end-of-file fixing.</li> <li><code>black</code>: For automated Python code formatting.</li> <li><code>ruff</code>: For Python linting and style checking.</li> <li><code>codespell</code>: For checking spelling errors.</li> <li><code>prettier</code>: For formatting non-Python files (e.g., Markdown, YAML).</li> <li><code>markdownlint-cli2</code>: For linting Markdown files.</li> </ul>"},{"location":"internal/architecture/development_setup/#3-versioning-strategy","title":"3. Versioning Strategy","text":"<p>The project uses an automated versioning system based on <code>bump2version</code> and conventional commits.</p> <ul> <li>Source of Truth: The version number is stored in a <code>manifest.json</code> file (e.g., <code>custom_components/my_integration/manifest.json</code>). The versioning scheme should follow semantic versioning (e.g., <code>1.2.3</code>).</li> <li>Automation Tool: <code>bump2version</code> is used to increment the version number. A <code>.bumpversion.cfg</code> file must be created to configure it:</li> <li>It should be configured to update the version in the <code>manifest.json</code> file.</li> <li>It should have <code>commit = False</code> and <code>tag = False</code> set, as the CI/CD pipeline will handle this.</li> <li>Pull Request Titles: The version increment type is determined by the pull request title:</li> <li><code>[major]</code>: For a major version increment (e.g., <code>1.x.x</code> -&gt; <code>2.0.0</code>).</li> <li><code>[minor]</code>: For a minor version increment (e.g., <code>1.2.x</code> -&gt; <code>1.3.0</code>).</li> <li>If neither is present, a <code>patch</code> increment is performed by default (e.g., <code>1.2.3</code> -&gt; <code>1.2.4</code>).</li> <li>Version Synchronization: A <code>package.json</code> file should be used for Node.js dependencies. The version in this file must be kept in sync with the version in <code>manifest.json</code>. A script (e.g., <code>get-version.js</code>) should be created to read the version from <code>manifest.json</code>.</li> </ul>"},{"location":"internal/architecture/development_setup/#4-cicd-pipeline-github-actions","title":"4. CI/CD Pipeline (GitHub Actions)","text":"<p>The CI/CD pipeline is implemented using GitHub Actions. The following workflows are required:</p> <p>**4.1. Code Quality and Testing (<code>python-lint.yaml</code>)</p> <ul> <li>Trigger: On pushes and pull requests to the <code>main</code> branch.</li> <li> <p>Steps:</p> </li> <li> <p>Set up Python 3.9.</p> </li> <li>Install Python dependencies from <code>requirements_dev.txt</code>.</li> <li>Run <code>black --check</code> to verify code formatting.</li> <li>Run <code>flake8</code> for linting.</li> <li>Run <code>mypy</code> for static type checking.</li> <li>Run <code>pydocstyle</code> for docstring style checking.</li> <li>Run <code>bandit</code> for security scanning.</li> <li>Run <code>pytest</code> to execute the test suite and generate a coverage report.</li> <li>(Optional) Upload the coverage report to a service like Codecov.</li> </ul> <p>**4.2. Home Assistant Validation (Optional, for HA projects)</p> <ul> <li>If the project is a Home Assistant custom component, two validation workflows should be included:</li> <li><code>validate.yaml</code>: Uses the <code>hacs/action</code> to validate the project for the Home Assistant Community Store.</li> <li><code>hassfest.yaml</code>: Uses the <code>home-assistant/actions/hassfest</code> action to perform Home Assistant specific validation.</li> </ul> <p>**4.3. Documentation Deployment (<code>mkdocs-deploy.yaml</code>)</p> <ul> <li>Trigger: On the creation of a new release.</li> <li>Steps:</li> <li>Set up Python.</li> <li>Install development dependencies.</li> <li>Build the documentation using <code>mkdocs build</code>.</li> <li>Deploy the generated <code>site</code> directory to the <code>gh-pages</code> branch using the <code>peaceiris/actions-gh-pages</code> action.</li> </ul> <p>**4.4. Versioning and Release (<code>version_and_release.yaml</code>)</p> <ul> <li>Trigger: When a pull request is closed and merged into the <code>main</code> branch.</li> <li>Job 1: <code>version</code></li> <li>Check out the <code>main</code> branch.</li> <li>Set up Python and Node.js.</li> <li>Install <code>bump2version</code> and <code>npm</code> dependencies.</li> <li>Determine the version increment type from the PR title.</li> <li>Run <code>bumpversion</code> to update the version in <code>manifest.json</code>.</li> <li>Update the version in <code>package.json</code>.</li> <li>Generate a <code>CHANGELOG.md</code> file using <code>conventional-changelog-cli</code>.</li> <li>Commit the updated files (<code>manifest.json</code>, <code>package.json</code>, <code>.bumpversion.cfg</code>, <code>CHANGELOG.md</code>) back to the <code>main</code> branch.</li> <li>Upload the release notes as an artifact.</li> <li>Job 2: <code>release</code></li> <li>Depends on the successful completion of the <code>version</code> job.</li> <li>Download the release notes artifact.</li> <li>Create a new GitHub release with a tag in the format <code>vX.Y.Z</code> and the release notes as the body.</li> </ul>"},{"location":"internal/architecture/layered_architecture/","title":"Layered architecture","text":"<p>**AI Agent Instructions</p> <p>Primary Objective: Refactor the <code>meraki_ha</code> Home Assistant integration to a modern, layered architecture that is scalable, highly testable, and robust against API failures. Prioritize a modular design to enable future feature expansion without significant refactoring.</p> <p>Core Instructions:</p> <ol> <li>Strictly Adhere to the Implementation Plan: Follow the provided ## Updated Design and Implementation Plan** sequentially. Do not deviate from the specified phases and components.</li> <li>Focus on Unit Testing: Write comprehensive unit tests for each new class and function as you develop it. Use in-memory mocks for any external dependencies (e.g., the <code>MerakiApiClient</code> and <code>MerakiRepository</code>). Minimize the number of full integration tests to conserve disk space.</li> <li>Modular Code Structure: Create separate Python files and directories as outlined in the plan (e.g., <code>meraki_ha/api/</code>, <code>meraki_ha/repository/</code>, <code>meraki_ha/hubs/</code>). Ensure each file contains a single, well-defined class or module.</li> <li>Clear Documentation: Add docstrings to all new classes and public methods, explaining their purpose, parameters, and return values. This is crucial for future maintenance and for other agents.</li> <li>Git Commits: Make small, logical commits for each completed sub-task (e.g., \"feat: Implement MerakiApiClient with circuit breaker,\" \"refactor: Add MerakiRepository and FSM\").</li> </ol> <p>Constraints &amp; Guidelines:</p> <ul> <li>No Unnecessary Packages: Only install libraries that are strictly necessary for the new architecture (e.g., <code>tenacity</code> for the circuit breaker, if not already present).</li> <li>Disk Space Management: Be mindful of disk usage during testing. Delete any temporary files generated and avoid storing large test fixtures in the codebase.</li> <li>Handle Errors Gracefully: Implement robust error handling at all layers, logging issues clearly without crashing the integration.</li> </ul> <p>**Updated Design and Implementation Plan</p> <p>This plan is a cohesive roadmap for refactoring the <code>meraki_ha</code> integration. It combines a robust architectural design with a practical, step-by-step implementation guide, built to be executed by AI coding agents.</p>"},{"location":"internal/architecture/layered_architecture/#architectural-design-a-layered-and-modular-approach","title":"**Architectural Design: A Layered and Modular Approach","text":"<p>The architecture is based on a clean separation of concerns, ensuring each component has a single, well-defined responsibility.</p> <ul> <li>API Layer: The <code>MerakiApiClient</code> handles low-level HTTP requests and responses. It is a stateless, pure client.</li> <li>Data Access Layer: The <code>MerakiRepository</code> sits on top of the <code>MerakiApiClient</code>. It is responsible for caching data, managing the API connection state with a Finite State Machine (FSM), and handling retries/rate-limiting.</li> <li>Logic Layer: The <code>OrganizationHub</code> and <code>NetworkHub</code> orchestrate the integration's logic. They are responsible for polling at appropriate intervals and managing the Home Assistant device/entity registry. They are decoupled from data access via Dependency Injection (DI) of the <code>MerakiRepository</code>.</li> <li>Entity Discovery Layer: A modular <code>DeviceDiscoveryService</code> uses a collection of device-specific <code>Handlers</code> to dynamically create Home Assistant entities. This pattern makes adding support for new devices straightforward.</li> </ul>"},{"location":"internal/architecture/layered_architecture/#implementation-plan","title":"**Implementation Plan","text":"<p>Phase 1: Foundational Layers (API Client &amp; Repository)</p> <ol> <li>Develop <code>MerakiApiClient</code> (<code>meraki_ha/api/client.py</code>):</li> <li>Create a class to handle all raw Meraki API calls.</li> <li>Integrate a circuit breaker pattern to handle API rate limits (<code>429</code>) and server errors gracefully. Use <code>tenacity</code> for asynchronous retries with exponential backoff.</li> <li> <p>Do not implement caching at this layer.</p> </li> <li> <p>Develop <code>MerakiRepository</code> (<code>meraki_ha/repository/repository.py</code>):</p> </li> <li>Create this new class to act as the primary data source for the hubs. It will take the <code>MerakiApiClient</code> as a constructor argument (Dependency Injection).</li> <li>Implement an in-memory caching mechanism with a time-to-live (TTL) for each data type.</li> <li>Implement a Finite State Machine (FSM) to track the API connection status (e.g., <code>CONNECTED</code>, <code>RATE_LIMITED</code>, <code>DISCONNECTED</code>). The state will determine whether API calls are made.</li> </ol> <p>Phase 2: Core Logic and Dependency Injection</p> <ol> <li>Refactor <code>OrganizationHub</code> and <code>NetworkHub</code> (<code>meraki_ha/hubs/</code>):</li> <li>Update the <code>OrganizationHub</code> and <code>NetworkHub</code> classes to accept the <code>MerakiRepository</code> via their constructors.</li> <li>All data retrieval logic within these hubs must now go through the injected repository.</li> <li> <p>Update the polling logic to leverage the repository's FSM state.</p> </li> <li> <p>Update <code>__init__.py</code> and <code>config_flow.py</code>:</p> </li> <li>In the <code>config_flow</code>, create a single instance of the <code>MerakiApiClient</code>.</li> <li>Pass this client to create a single instance of the <code>MerakiRepository</code>.</li> <li>Finally, pass the <code>MerakiRepository</code> to the new <code>OrganizationHub</code> when it is set up.</li> </ol> <p>Phase 3: Modular Entity Discovery</p> <ol> <li>Develop <code>DeviceHandlers</code> (<code>meraki_ha/discovery/handlers/</code>):</li> <li>Create a base <code>BaseDeviceHandler</code> class.</li> <li>Create individual handler classes for each device type (e.g., <code>MTHandler</code>, <code>MRHandler</code>, <code>MSHandler</code>) that inherit from <code>BaseDeviceHandler</code>.</li> <li> <p>Each handler will contain the logic to check if a device is of its type and, if so, to create the correct Home Assistant entities (sensors, binary sensors, etc.).</p> </li> <li> <p>Create <code>DeviceDiscoveryService</code> (<code>meraki_ha/discovery/service.py</code>):</p> </li> <li>Create a service class that takes a list of all the <code>DeviceHandlers</code> in its constructor.</li> <li> <p>Add a single method, <code>discover_entities(devices)</code>, that iterates through the list of Meraki devices and passes each one to the handlers to process.</p> </li> <li> <p>Integrate Service into <code>NetworkHub</code>:</p> </li> <li>Modify the <code>NetworkHub</code>'s update method to call the new <code>DeviceDiscoveryService</code>.</li> </ol> <p>Phase 4: Testing and Project Cleanup</p> <ol> <li>Write Comprehensive Unit Tests:</li> <li>Write isolated unit tests for the <code>MerakiRepository</code> using an in-memory mock for the <code>MerakiApiClient</code>.</li> <li>Write unit tests for the <code>OrganizationHub</code> and <code>NetworkHub</code> by injecting a mock <code>MerakiRepository</code>.</li> <li>Create unit tests for each <code>DeviceHandler</code> class to confirm it correctly identifies devices and creates entities.</li> <li> <p>Adhere to a <code>pytest</code> structure that allows for running only unit tests via a marker, reducing overhead.</p> </li> <li> <p>Final Project Cleanup:</p> </li> <li>Remove all old, deprecated polling logic.</li> <li>Ensure all new files and directories are correctly added to version control.</li> <li>Confirm docstrings and inline comments are clear and concise.</li> </ol> <p>A common source of these issues is monolithic files that contain too much logic. While the previous plan focused on architectural patterns, we can refine the implementation details to specifically combat file complexity. The solution is to prioritize function decomposition and separation of concerns at a granular level.</p> <p>**Updated AI Agent Instructions</p> <ol> <li>Strictly Enforce File Size Limits: Do not create any single Python file with more than 300 lines of code. If a file approaches this limit, stop and refactor the logic into new, smaller files.</li> <li>Prioritize Function Decomposition: Every function must have a single, clear responsibility. If a function's name includes \"and\" or \"or,\" it likely needs to be broken into smaller functions.</li> <li>Eliminate Deeply Nested Code: Avoid <code>if-elif-else</code> chains and nested loops that go beyond three levels of indentation. Use guard clauses (early returns) and extract nested logic into separate, well-named functions.</li> <li>Use Private Helper Methods: For logic that supports a public method but is not meant to be called externally, use private helper methods (prefixed with <code>_</code>) to keep the primary method's body clean and readable.</li> </ol> <p>**Updated Implementation Plan</p> <p>The core architectural plan remains sound, but this update adds an additional layer of detail to the implementation steps, ensuring the resulting code is modular and readable for both humans and AI agents.</p>"},{"location":"internal/architecture/layered_architecture/#phase-1-foundational-layers-api-client-repository","title":"**Phase 1: Foundational Layers (API Client &amp; Repository)","text":"<ol> <li>Develop <code>MerakiApiClient</code> (<code>meraki_ha/api/client.py</code>):</li> <li>Focus on Single-Responsibility Methods: Each method should correspond to a single Meraki API endpoint (e.g., <code>get_network_devices</code>, <code>get_mt_sensors</code>).</li> <li> <p>Limit Indentation: Use guard clauses to handle invalid inputs or API errors upfront, minimizing nested <code>try-except</code> blocks.</p> </li> <li> <p>Develop <code>MerakiRepository</code> (<code>meraki_ha/repository/repository.py</code>):</p> </li> <li>Decompose Complex Logic: The methods here (e.g., <code>_async_update_cache</code>) should be broken down into smaller, private methods if they exceed 30 lines of code.</li> </ol>"},{"location":"internal/architecture/layered_architecture/#phase-2-core-logic-and-dependency-injection","title":"**Phase 2: Core Logic and Dependency Injection","text":"<ol> <li>Refactor <code>OrganizationHub</code> and <code>NetworkHub</code> (<code>meraki_ha/hubs/</code>):</li> <li>Extract Logic into Helper Methods: The main <code>_async_update_data</code> method should primarily serve as an orchestrator. Move complex data processing, filtering, or transformation logic into private helper methods within the same file.</li> <li>Maintain Small File Sizes: If a hub's file becomes too large, consider whether some of its logic could be moved to a dedicated service class (e.g., <code>meraki_ha/services/state_manager.py</code>).</li> </ol>"},{"location":"internal/architecture/layered_architecture/#phase-3-modular-entity-discovery","title":"**Phase 3: Modular Entity Discovery","text":"<ol> <li>Develop <code>DeviceHandlers</code> (<code>meraki_ha/discovery/handlers/</code>):</li> <li> <p>Enforce the 300-Line Limit: If a handler file (e.g., <code>MRHandler.py</code>) becomes too large, it suggests that the handler is trying to do too much. Break its entity creation logic into multiple, separate functions.</p> </li> <li> <p>Create <code>DeviceDiscoveryService</code> (<code>meraki_ha/discovery/service.py</code>):</p> </li> <li>Simplify the Core Loop: Ensure the <code>discover_entities</code> method is a simple loop that delegates all complex work to the <code>DeviceHandlers</code>. The code should be clear and have a low cyclomatic complexity.</li> </ol>"},{"location":"internal/architecture/layered_architecture/#phase-4-testing-and-project-cleanup","title":"**Phase 4: Testing and Project Cleanup","text":"<ol> <li>Prioritize Lightweight Tests: When writing tests, focus on testing individual methods and functions, not entire classes. This keeps test files small and prevents the need for large, deeply nested test fixtures.</li> <li>Linting and Formatting: Use automated tools like <code>black</code> or <code>ruff</code> to ensure consistent code style and formatting across the entire project. This improves readability and helps prevent subtle errors that can be caused by inconsistent indentation.</li> </ol>"},{"location":"internal/architecture/ssids/","title":"Ssids","text":"<p>**AI Agent Instructions</p> <p>Persona: A pragmatic and experienced software architect, focused on creating scalable and maintainable solutions.</p> <p>Objective: The primary goal is to refactor the Meraki SSID component to function as a \"virtual\" Home Assistant device, moving its entities from the main organization device to a new, dedicated device representation. This requires a strong understanding of object-oriented principles and the Home Assistant device model.</p> <p>Task Requirements:</p> <ol> <li>Device-centric Model: The agent must conceptualize the Meraki SSID as a distinct Home Assistant device. This involves creating a new device representation for each SSID and associating all its related entities (e.g., sensors for client counts, switches for broadcasting) with this new virtual device.</li> <li>Handler Creation: A dedicated handler, <code>SSIDHandler</code>, must be created. This handler will be responsible for discovering the virtual SSID devices and their corresponding entities. It should follow the same pattern as other device handlers (e.g., <code>MRHandler</code>, <code>MVHandler</code>).</li> <li>Dependency Injection: The <code>SSIDHandler</code> must be designed to receive necessary services, such as a new <code>SSIDService</code> or the existing <code>DeviceControlService</code>, through its <code>__init__</code> method.</li> <li>Entity Association: The agent must ensure that all SSID-related entities, such as the <code>MerakiClientCountSensor</code> and <code>MerakiBroadcastSwitch</code>, are correctly associated with the new virtual SSID device, not the physical network device (e.g., the MR or MX).</li> <li>Clean Code and Abstraction: The code should be well-structured, with clear separation of concerns. The <code>SSIDHandler</code> should abstract the logic of creating SSID-specific entities and devices.</li> <li>Comprehensive Testing: The agent must update existing tests and create new ones to validate that the <code>SSIDHandler</code> correctly discovers and creates the virtual SSID device and all its entities. The tests should verify the correct device association for each entity.</li> </ol> <p>**Implementation Plan</p> <p>The refactoring will be executed in a phased, step-by-step approach to ensure a seamless migration to the new device model.</p> <ol> <li>Phase 1: Handler and Service Creation</li> <li>Create <code>SSIDHandler</code>: Create a new file, <code>custom_components/meraki_ha/discovery/handlers/ssid.py</code>.</li> <li>This handler will inherit from <code>BaseDeviceHandler</code>.</li> <li>Its <code>__init__</code> method will accept <code>coordinator</code>, <code>config_entry</code>, and a new <code>SSIDService</code> (or <code>DeviceControlService</code>, if applicable) as arguments.</li> <li> <p>Implement the <code>discover_entities</code> method. This method will iterate through the list of SSIDs and for each one, create a virtual Home Assistant device using the <code>Device</code> class and then create the associated entities (sensors, switches), linking them to the new device using the <code>device_info</code> property.</p> </li> <li> <p>Phase 2: Updating the Discovery Service</p> </li> <li>Modify <code>DeviceDiscoveryService</code>: Open <code>custom_components/meraki_ha/discovery/service.py</code>.</li> <li>Import the new <code>SSIDHandler</code>.</li> <li>Update the <code>__init__</code> method to instantiate and store a new <code>SSIDService</code> if needed, and/or pass the existing <code>DeviceControlService</code> to the <code>SSIDHandler</code> when it is instantiated.</li> <li> <p>In the <code>discover_entities</code> method, add a new block of code to specifically call the <code>SSIDHandler</code> and collect its entities. Since SSIDs are not physical devices, this handler will need to be called separately from the loop that iterates through physical devices (<code>_devices</code>).</p> </li> <li> <p>Phase 3: Entity Refactoring and Association</p> </li> <li>Update SSID Entities: Open the existing files for the SSID-related entities (e.g., <code>custom_components/meraki_ha/sensor/ssid_client_count.py</code>, <code>custom_components/meraki_ha/switch/ssid_broadcast.py</code>).</li> <li>Modify their <code>__init__</code> methods to accept a <code>device_info</code> object that represents the new virtual SSID device.</li> <li> <p>Update their <code>device_info</code> property to use the unique SSID identifier to link the entity to the virtual device instead of the main organization device.</p> </li> <li> <p>Phase 4: Testing and Validation</p> </li> <li>Create <code>test_ssid_handler.py</code>: Add a new unit test file to thoroughly test the <code>SSIDHandler</code>.</li> <li>Test cases should include:<ul> <li>Verifying that the handler successfully creates a virtual device for each SSID.</li> <li>Confirming that all SSID-related entities are correctly created and linked to their respective virtual devices.</li> <li>Asserting that no entities are incorrectly associated with the main organization device.</li> </ul> </li> <li>Execute all tests and perform manual verification within a Home Assistant environment.</li> </ol>"},{"location":"internal/architecture/switches/","title":"AI Agent Instructions","text":"<p>Your task is to refactor the <code>meraki_ha</code> integration to properly represent Meraki MS/GS switch ports as Home Assistant entities. This includes creating a visual status indicator that changes based on whether a port is connected or disconnected. The refactor must be modular and testable, adhering to all previous instructions regarding file size and code structure.</p> <ol> <li>Use the correct API endpoint: The Meraki API has a dedicated endpoint to get the status for all ports of a switch: <code>/devices/{serial}/switch/ports/statuses</code>. You must use this endpoint to retrieve the port status, speed, duplex, and other relevant information.</li> <li>Modularize port logic: Create a dedicated service for handling switch port data. This will include methods for retrieving a specific port's status and for parsing the raw data.</li> <li>Implement the visual indicator: You must create a Home Assistant entity that automatically changes its icon to reflect the port's status. For a connected port, use a green icon, and for a disconnected port, use a red icon. You can use standard Home Assistant icons like <code>mdi:lan-connect</code> and <code>mdi:lan-disconnect</code> and leverage the <code>state_color</code> property to make the icon green or red based on the entity's state.</li> </ol>"},{"location":"internal/architecture/switches/#refactor-plan-for-meraki-msgs-switches","title":"Refactor Plan for Meraki MS/GS Switches","text":"<p>This plan will integrate switch port monitoring into the existing architecture by adding a new service layer and updating the <code>MSHandler</code> to dynamically create a binary sensor for each port.</p> <p>**Phase 1: API and Repository Updates</p> <ol> <li>Add <code>getDeviceSwitchPortsStatuses</code> to <code>MerakiApiClient</code>:</li> <li> <p>Add a new asynchronous method, <code>async_get_switch_port_statuses(serial)</code>, that calls the Meraki API's <code>/devices/{serial}/switch/ports/statuses</code> endpoint. This will return a list of all ports and their current status.</p> </li> <li> <p>Add <code>get_switch_port_statuses</code> to <code>MerakiRepository</code>:</p> </li> <li>Create a new method, <code>async_get_switch_port_statuses(serial)</code>, in the repository.</li> <li>This method will accept the switch's serial number and call the API client. The repository will handle caching the results with a short TTL (e.g., 60 seconds) since port status can change frequently.</li> </ol> <p>**Phase 2: Create a Dedicated Switch Port Service</p> <ol> <li>Develop <code>SwitchPortService</code> (<code>meraki_ha/services/switch_port_service.py</code>):</li> <li>Create a new class, <code>SwitchPortService</code>, that is injected with the <code>MerakiRepository</code>.</li> <li> <p>This service will contain methods for handling switch port data, such as:</p> <ul> <li><code>async_get_port_status(serial, port_id)</code>: A method that queries the repository and returns the status (<code>Connected</code> or <code>Disconnected</code>) for a specific port.</li> <li><code>async_get_port_speed(serial, port_id)</code>: A similar method to get the port's current speed.</li> </ul> </li> <li> <p>Update <code>MSHandler</code>:</p> </li> <li>The <code>MSHandler</code> needs to be updated to accept the <code>SwitchPortService</code> via Dependency Injection.</li> </ol> <p>**Phase 3: Dynamic Entity Creation and Visual Indicators</p> <ol> <li>Refactor <code>MSHandler</code>:</li> <li>During device discovery, after identifying a Meraki MS switch, the handler must iterate through all of its ports.</li> <li>For each port, the handler will create a new binary sensor Home Assistant entity. A binary sensor is ideal for representing a simple \"on/off\" or \"connected/disconnected\" state.</li> <li>The sensor's state will be set to <code>on</code> if the port status is 'Connected' and <code>off</code> if it's 'Disconnected'.</li> <li>Implement the visual indicator: When creating the binary sensor entity, use the <code>device_class</code> property with <code>connectivity</code>. This tells Home Assistant to use a specific icon set for connected devices. For a more direct visual, you can also set the <code>icon</code> attribute and the <code>state_color</code> attribute to <code>True</code> on the entity. Home Assistant will then automatically color the icon based on the state. For example, the icon will be green when the state is <code>on</code> and gray when the state is <code>off</code>.</li> </ol> <p>**Phase 4: Testing and Cleanup</p> <ol> <li>Write New Unit Tests:</li> <li>Write tests for the <code>SwitchPortService</code> to ensure it correctly parses data from mock API responses.</li> <li>Create tests for the <code>MSHandler</code> that verify it correctly creates a binary sensor for each port on a mock switch and sets the <code>device_class</code> and other properties correctly.</li> <li>Remove Old Code:</li> <li>Remove any old or incorrect methods for retrieving switch port status. All status checks must now be routed through the new <code>SwitchPortService</code>.</li> </ol>"},{"location":"internal/architecture/switches/#ssid-switches","title":"SSID Switches","text":"<p>The integration provides two switches for each SSID (Service Set Identifier) on a wireless network, allowing for fine-grained control over its availability and visibility.</p> <p>**SSID Enable Switch</p> <ul> <li>Name: <code>SSID Enable</code></li> <li>Purpose: This switch controls the operational state of the SSID.</li> <li>ON: The SSID is enabled and active. Wireless clients can associate with it.</li> <li>OFF: The SSID is disabled. No clients can connect.</li> </ul> <p>**SSID Broadcast Switch</p> <ul> <li>Name: <code>SSID Broadcast</code></li> <li>Purpose: This switch controls whether the SSID's name (its \"broadcast\") is visible to nearby devices. This is also known as a \"hidden\" network.</li> <li>ON: The SSID is visible. Its name will appear in the list of available Wi-Fi networks on client devices.</li> <li>OFF: The SSID is hidden. Its name will not appear in Wi-Fi scans, and users must manually enter the SSID name to connect.</li> <li>Availability: This switch is only available when the <code>SSID Enable</code> switch is in the ON state. If the SSID is disabled, it cannot broadcast, so this control becomes unavailable.</li> </ul>"},{"location":"internal/architecture/wireless/","title":"Agent Instructions","text":"<p>The agent's primary objective is to refactor the Meraki MR and GR components to align with the new, service-based architecture of the Home Assistant integration. The agent must adhere to the following instructions:</p> <ol> <li>Objective: The core task is to create a unified and scalable architecture for Meraki devices by refactoring the MR and GR components.</li> <li>Service-Oriented Design: The agent must exclusively use the <code>DeviceControlService</code> for all device management functions, such as rebooting or upgrading firmware. This service will be injected into the component handlers during discovery.</li> <li>Handler Consolidation: The agent should ensure the new MR and GR handlers inherit from a common base class, such as <code>BaseDeviceHandler</code>, to reduce redundant code and standardize the interface for device discovery.</li> <li>Preservation of Functionality: The refactor must not introduce any regressions. Existing functionalities, such as sensor discovery for MR devices, must continue to work as intended.</li> <li>Code Quality: The code produced must be clean, well-commented, and conform to the PEP 8 Python style guide. All new functions and classes should have clear docstrings.</li> <li>Testing Protocol: After the refactor, the agent must ensure that all existing unit tests for the MR and GR components pass. Additionally, new tests must be created to cover the new dependency injection pattern and the use of the <code>DeviceControlService</code>.</li> </ol>"},{"location":"internal/architecture/wireless/#integration-plan","title":"Integration Plan","text":"<p>The refactoring and integration will be executed in a phased, step-by-step approach to minimize disruption and ensure a smooth transition to the new architecture.</p> <ol> <li>Define a Base Handler Class: Create a new file for a <code>BaseDeviceHandler</code> class. This class will provide a common blueprint for all device handlers and will contain shared properties and methods, such as the <code>coordinator</code> and <code>config_entry</code>.</li> <li>Refactor the <code>MRHandler</code> and <code>GRHandler</code>:</li> <li>Modify both <code>MRHandler</code> and <code>GRHandler</code> classes to inherit from the newly created <code>BaseDeviceHandler</code>.</li> <li>Update the <code>__init__</code> method in both classes to accept an instance of the <code>DeviceControlService</code> as a dependency. The new <code>__init__</code> will call <code>super().__init__()</code> and store the <code>DeviceControlService</code> instance for later use.</li> <li>Refactor the <code>discover_entities</code> methods within both handlers to use the injected <code>DeviceControlService</code> for any control-related tasks.</li> <li>Update the <code>DeviceDiscoveryService</code>:</li> <li>Add the <code>GRHandler</code> to the <code>HANDLER_MAPPING</code> dictionary in the <code>DeviceDiscoveryService</code> to ensure GR devices are handled correctly.</li> <li>Modify the <code>discover_entities</code> method to pass the <code>DeviceControlService</code> instance to the constructors of both the <code>MRHandler</code> and <code>GRHandler</code> when they are instantiated.</li> <li>Modify the Platform Setup (<code>__init__.py</code>):</li> <li>Update the <code>async_setup_entry</code> function in the respective platform files (<code>binary_sensor/__init__.py</code>, <code>sensor/__init__.py</code>, etc.) to create an instance of the <code>DeviceControlService</code>.</li> <li>Pass this new service instance to the <code>DeviceDiscoveryService</code> when it is initialized, so it can be distributed to the appropriate handlers.</li> <li>Validation and Finalization:</li> <li>Execute all unit tests to confirm the refactoring has not introduced any errors. Address any failures immediately.</li> <li>Run the Home Assistant integration with the new code to verify that both MR and GR devices are discovered correctly and all entities function as expected.</li> <li>Remove any legacy code and imports that are no longer needed, ensuring a clean and efficient final codebase.</li> </ol>"},{"location":"internal/testing/TEST_SERVER/","title":"Testing","text":""},{"location":"internal/testing/TEST_SERVER/#1-test-server-requirements-document","title":"1. Test Server Requirements Document","text":""},{"location":"internal/testing/TEST_SERVER/#objective","title":"Objective","text":"<p>To achieve an autonomous, observability-driven testing loop that validates integration health through live deployment, real-time log analysis, and automated self-correction.</p>"},{"location":"internal/testing/TEST_SERVER/#autonomous-infrastructure","title":"Autonomous Infrastructure","text":"<ul> <li>Test Server: A Home Assistant instance (OS or Docker) reachable via SSH.</li> <li>Log Shipper: Fluent Bit installed as a service or Docker container on the test server.</li> <li>Observability Platform: Better Stack (Logs) with an HTTP source.</li> <li>Secrets Management:</li> <li><code>SMOKE_TEST_SERVER_IP</code>: The address of the test box.</li> <li><code>SMOKE_TEST_SSH_KEY</code>: Private key for deployment.</li> <li><code>BETTER_STACK_SOURCE_TOKEN</code>: The unique token from your Better Stack HTTP source.</li> <li><code>BETTER_STACK_API_TOKEN</code>: Used by Jules to query logs programmatically.</li> <li><code>HA_TEST_TOKEN</code>: Long-lived access token for HA API/CLI.</li> </ul>"},{"location":"internal/testing/TEST_SERVER/#2-detailed-implementation-plan","title":"2. Detailed Implementation Plan","text":""},{"location":"internal/testing/TEST_SERVER/#phase-1-log-forwarding-setup","title":"Phase 1: Log Forwarding Setup","text":"<p>Jules will generate and deploy a <code>fluent-bit.conf</code> to the test server. This configuration monitors the <code>home-assistant.log</code> and ships it to Better Stack.</p> <ul> <li>Input: <code>tail</code> plugin pointing to <code>/config/home-assistant.log</code>.</li> <li>Output: <code>http</code> plugin pointing to <code>in.logs.betterstack.com</code> using your source token.</li> </ul>"},{"location":"internal/testing/TEST_SERVER/#phase-2-deployment-orchestration","title":"Phase 2: Deployment &amp; Orchestration","text":"<ul> <li>Sync: Workflow uses <code>rsync</code> to push code to <code>/config/custom_components/meraki_ha/</code>.</li> <li>Reboot: Workflow triggers <code>hass-cli service call homeassistant.restart</code>.</li> <li>Wait: Polling loop monitors the <code>/api/config</code> endpoint until the state is <code>RUNNING</code>.</li> </ul>"},{"location":"internal/testing/TEST_SERVER/#phase-3-the-multi-vector-audit","title":"Phase 3: The Multi-Vector Audit","text":"<ol> <li>State Audit: <code>scripts/smoke_test_probe.py</code> connects via WebSockets to verify that the <code>meraki_ha</code> domain is loaded and entities are not <code>unavailable</code>.</li> <li>Log Audit: A new script <code>scripts/check_better_stack.py</code> queries the Better Stack API for any <code>ERROR</code> level logs containing \"meraki_ha\" that occurred in the 5 minutes post-deployment.</li> </ol>"},{"location":"internal/testing/TEST_SERVER/#phase-4-autonomous-bug-reporting","title":"Phase 4: Autonomous Bug Reporting","text":"<p>If either audit fails:</p> <ul> <li>Jules extracts the Traceback and Entity State data.</li> <li>Jules creates a GitHub issue titled \"Smoke Test Failure: [Commit ID]\".</li> <li>The issue description serves as the \"Fix It\" prompt for the next Healer cycle.</li> </ul>"},{"location":"internal/testing/TEST_SERVER/#4-fluent-bit-configuration-for-jules-to-deploy","title":"4. Fluent Bit Configuration (For Jules to Deploy)","text":"<p>Jules should use this configuration to set up the log shipping:</p> <pre><code>[SERVICE]\n    Flush        1\n    Daemon       Off\n    Log_Level    info\n\n[INPUT]\n    Name         tail\n    Path         /config/home-assistant.log\n    Tag          ha.logs\n    DB           /tmp/fluent-bit.db\n\n[FILTER]\n    Name         grep\n    Match        ha.logs\n    Regex        log .*meraki_ha.*\n\n[OUTPUT]\n    Name         http\n    Match        ha.logs\n    Host         in.logs.betterstack.com\n    Port         443\n    URI          /\n    Header       Authorization Bearer ${{ secrets.BETTER_STACK_SOURCE_TOKEN }}\n    Format       json\n    tls          On\n\n</code></pre>"},{"location":"internal/testing/testing_plan/","title":"Web UI End-to-End Testing Plan","text":"<p>This document outlines the end-to-end test cases for the self-hosted web interface. The tests are prioritized to ensure the most critical user journeys are validated first.</p>"},{"location":"internal/testing/testing_plan/#p0-critical-path-tests","title":"P0: Critical Path Tests","text":"<p>These tests cover the most critical user journeys and must pass for the feature to be considered stable.</p> <p>**Test Case: UI-P0-01 - View Dashboard with Data</p> <ul> <li>Priority: P0</li> <li>Description: Ensures a user can open the web UI and see the main dashboard populated with network and client data.</li> <li>Preconditions:</li> <li>The Meraki integration is configured and running.</li> <li>The Web UI is enabled on the default port (9988).</li> <li>The backend coordinator has successfully fetched at least one network and one client.</li> <li> <p>Steps:</p> </li> <li> <p>Navigate to the web UI URL (e.g., <code>http://&lt;home-assistant-ip&gt;:9988</code>).</p> </li> <li>Wait for the page to load.</li> <li>Observe the \"Networks\" card.</li> <li> <p>Observe the \"Clients\" card.</p> </li> <li> <p>Expected Result:</p> </li> <li>The page loads without errors.</li> <li>The \"Networks\" card displays a list of networks, matching the data from the backend.</li> <li>The \"Clients\" card displays a list of clients, matching the data from the backend.</li> </ul> <p>**Test Case: UI-P0-02 - Navigate to Network Detail View</p> <ul> <li>Priority: P0</li> <li>Description: Ensures a user can navigate from the dashboard to a network's detail page and see the correct data.</li> <li>Preconditions:</li> <li>Test Case UI-P0-01 is passing.</li> <li>Steps:</li> <li>On the dashboard, click on the first network card in the \"Networks\" list.</li> <li>Observe the new page that loads.</li> <li>Expected Result:</li> <li>The URL changes to <code>/networks/&lt;network-id&gt;</code>.</li> <li>The network detail page loads.</li> <li>The page title or header contains the name of the clicked network.</li> <li>The details displayed on the page (ID, name, tags, etc.) match the data for that specific network.</li> </ul> <p>**Test Case: UI-P0-03 - Navigate to Client Detail View</p> <ul> <li>Priority: P0</li> <li>Description: Ensures a user can navigate from the dashboard to a client's detail page and see the correct data.</li> <li>Preconditions:</li> <li>Test Case UI-P0-01 is passing.</li> <li>Steps:</li> <li>On the dashboard, click on the first client card in the \"Clients\" list.</li> <li>Observe the new page that loads.</li> <li>Expected Result:</li> <li>The URL changes to <code>/clients/&lt;client-mac&gt;</code>.</li> <li>The client detail page loads.</li> <li>The page title or header contains the description or MAC address of the clicked client.</li> <li>The details displayed on the page (MAC, IP, description, etc.) match the data for that specific client.</li> </ul>"},{"location":"internal/testing/testing_plan/#p1-high-priority-tests","title":"P1: High Priority Tests","text":"<p>These tests cover important configuration options and error handling cases.</p> <p>**Test Case: UI-P1-01 - UI is disabled via configuration</p> <ul> <li>Priority: P1</li> <li>Description: Ensures that when the web UI is disabled in the Home Assistant options, it is not accessible.</li> <li>Preconditions:</li> <li>The Meraki integration is configured and running.</li> <li>Steps:</li> <li>In Home Assistant, go to the Meraki integration's configuration.</li> <li>Uncheck the \"Enable Web UI\" option and save.</li> <li>Attempt to navigate to the web UI URL (e.g., <code>http://&lt;home-assistant-ip&gt;:9988</code>).</li> <li>Expected Result:</li> <li>The connection is refused. The page does not load.</li> </ul> <p>**Test Case: UI-P1-02 - Change UI Port</p> <ul> <li>Priority: P1</li> <li>Description: Ensures that changing the port in the configuration correctly moves the web UI.</li> <li>Preconditions:</li> <li>The Meraki integration is configured and running.</li> <li>Steps:</li> <li>In Home Assistant, go to the Meraki integration's configuration.</li> <li>Change the \"Web UI Port\" to a new value (e.g., 9989). Save the configuration.</li> <li>Attempt to navigate to the old port (9988).</li> <li>Navigate to the new port (9989).</li> <li>Expected Result:</li> <li>The connection to the old port is refused.</li> <li>The new port successfully loads the web UI dashboard.</li> </ul>"},{"location":"internal/testing/testing_plan/#p2-medium-priority-tests","title":"P2: Medium Priority Tests","text":"<p>These tests cover edge cases and less critical functionality.</p> <p>**Test Case: UI-P2-01 - Dashboard with no data</p> <ul> <li>Priority: P2</li> <li>Description: Ensures the UI loads gracefully if the backend returns no networks or clients.</li> <li>Preconditions:</li> <li>The Meraki integration is configured and running.</li> <li>The Web UI is enabled.</li> <li>The backend coordinator returns empty lists for networks and clients.</li> <li> <p>Steps:</p> </li> <li> <p>Navigate to the web UI URL.</p> </li> <li> <p>Expected Result:</p> </li> <li>The page loads without errors.</li> <li>The \"Networks\" card shows a count of 0 and an empty list.</li> <li>The \"Clients\" card shows a count of 0 and an empty list.</li> </ul>"},{"location":"refactoring/custom_panel_refactor/","title":"Requirements: Meraki Dashboard Refactor &amp; Dual-Compatibility (v2026.1)","text":""},{"location":"refactoring/custom_panel_refactor/#1-objective","title":"1. Objective","text":"<p>Refactor the custom Meraki panel into a native Home Assistant Dashboard utilizing the Sections view layout. This ensures full compatibility with 2026.1 navigation while providing a graceful Dual-Registration fallback for older versions.</p>"},{"location":"refactoring/custom_panel_refactor/#2-technical-specifications","title":"2. Technical Specifications","text":""},{"location":"refactoring/custom_panel_refactor/#a-framework-framework-migration","title":"A. Framework &amp; Framework Migration","text":"<ul> <li>Target Framework: Migrate all custom frontend components from legacy HTML/JS to Lit 3.x.</li> <li>Grid Intelligence: Components must implement <code>getGridOptions()</code> to support the native 2026.1 drag-and-drop grid.</li> <li>Styling: Utilize CSS variables (e.g., <code>--ha-card-background</code>, <code>--primary-text-color</code>) for automatic theme adaptation.</li> </ul>"},{"location":"refactoring/custom_panel_refactor/#b-navigation-dual-registration","title":"B. Navigation &amp; Dual-Registration","text":"<p>The backend (<code>__init__.py</code>) must detect the Home Assistant version to choose the registration method:</p> <ul> <li>v2026.1 or Newer:</li> <li>Register a Lovelace Dashboard via <code>frontend.async_register_built_in_panel</code>.</li> <li> <p>Dashboard Config: Set <code>view_type: \"sections\"</code> and include a default <code>ui-lovelace.yaml</code> layout.</p> </li> <li> <p>Older Versions:</p> </li> <li> <p>Fall back to <code>panel_custom</code> registration to maintain existing sidebar functionality and bookmarks.</p> </li> <li> <p>Common Settings: Icon: <code>mdi:lan-check</code>, <code>require_admin: false</code>.</p> </li> </ul>"},{"location":"refactoring/custom_panel_refactor/#c-layout-architecture-sections-view","title":"C. Layout Architecture (Sections View)","text":"<p>The dashboard will implement a three-tier priority grid:</p> <ol> <li>Connectivity Summary (Header):</li> <li>Version String: Display the integration version (e.g., \"2.0.0-beta.69\") prominently.</li> <li> <p>Live Status: A connectivity chip for Meraki Cloud health.</p> </li> <li> <p>Security &amp; Surveillance:</p> </li> <li> <p>WebRTC camera feeds using optimized 2026.1 \"Picture Glance\" or \"Sub-view\" cards.</p> </li> <li> <p>Network Controls:</p> </li> <li>Grouped SSID toggles and PoE switch management sections.</li> </ol>"},{"location":"refactoring/custom_panel_refactor/#3-data-flow-state-management","title":"3. Data Flow &amp; State Management","text":"<ul> <li>WebSocket API: Implement a new command <code>meraki_ha/get_version</code> to allow the Lit components to fetch the version string regardless of the registration method.</li> <li>Throttling: Apply a 500ms debounce to all network-wide toggles to prevent API rate-limiting.</li> <li>Interaction: Ensure clicking any card opens the native More Info dialog for full device details (IP, MAC, history).</li> </ul>"},{"location":"refactoring/custom_panel_refactor/#4-implementation-steps-for-jules","title":"4. Implementation Steps for Jules","text":"<ol> <li>Phase 1 (Backend): Implement version-checking logic in <code>__init__.py</code> and the new WebSocket command.</li> <li>Phase 2 (Frontend): Convert existing views into Lit 3.x components with grid support.</li> <li>Phase 3 (Configuration): Draft the default <code>ui-lovelace.yaml</code> Sections layout.</li> <li>Phase 4 (Validation): Deploy to the Smoke Test Server and verify:</li> <li>Version \"2.0.0-beta.69\" is displayed via WebSocket.</li> <li>The dashboard scales and flows correctly on the 2026.1 mobile view.</li> </ol>"},{"location":"refactoring/proactive_plan/","title":"Proactive Code Health Improvement Plan","text":"<p>This document outlines a high-level plan for improving the health and maintainability of the <code>meraki_ha</code> custom component, based on observations made during the <code>ha-refactor-fix2</code> debugging session.</p>"},{"location":"refactoring/proactive_plan/#1-full-test-suite-audit-refactor","title":"1. Full Test Suite Audit &amp; Refactor","text":"<p>Problem: The test suite was significantly out of sync with the application code, leading to a cascade of failures during refactoring. This indicates a lack of maintenance and makes future development risky and time-consuming.</p> <p>Action:</p> <ul> <li>Meticulously review every test file.</li> <li>Update tests that are failing due to signature changes in the application code.</li> <li>Delete obsolete tests that are no longer relevant to the current architecture.</li> <li>Refactor complex and brittle mocks to be simpler, more robust, and reusable.</li> <li>Prioritize fixing the core integration test (<code>test_ssid_device_creation_and_unification</code>) to ensure a reliable end-to-end check of the component setup workflow.</li> </ul>"},{"location":"refactoring/proactive_plan/#2-standardize-all-handler-interfaces","title":"2. Standardize All Handler Interfaces","text":"<p>Problem: Different device handlers (<code>MXHandler</code>, <code>GXHandler</code>, <code>MSHandler</code>, etc.) had inconsistent constructor signatures, making the discovery service logic complex and prone to <code>TypeError</code>s.</p> <p>Action:</p> <ul> <li>Enforce a standard, consistent interface for all classes that inherit from <code>BaseDeviceHandler</code>.</li> <li>This includes standardizing the arguments passed in the constructor.</li> <li>This will simplify the <code>DeviceDiscoveryService</code> and make it easier to add new handlers in the future.</li> </ul>"},{"location":"refactoring/proactive_plan/#3-improve-dependency-management","title":"3. Improve Dependency Management","text":"<p>Problem: The <code>DeviceDiscoveryService</code> constructor has a large and growing number of parameters. While explicit dependency injection is good, this can become unwieldy and hard to manage.</p> <p>Action:</p> <ul> <li>Investigate creating a dedicated \"services\" or \"context\" object.</li> <li>This object would act as a container for all necessary services (<code>control_service</code>, <code>camera_service</code>, <code>network_control_service</code>, etc.).</li> <li>The context object would be passed to the <code>DeviceDiscoveryService</code>, which can then access the services it needs.</li> <li>This will clean up constructor signatures across the application and make it easier to add new shared services in the future.</li> </ul>"},{"location":"requirements/","title":"Meraki Home Assistant Integration Requirements","text":""},{"location":"requirements/#core-functionality","title":"Core Functionality","text":"<p>**Meraki API Integration</p> Requirement Status The integration needs to communicate with the Cisco Meraki API to fetch data. Included It requires an API key and organization ID for authentication. Included The API key must be stored securely. Included <p>**Meraki Device Discovery and Setup</p> Requirement Status The integration must discover Meraki hardware devices within the specified organization and networks. Included It should create or update device entities in Home Assistant based on these hardware devices. Included Device types (Wireless, Switch, Appliance, Camera, Sensor) should be correctly identified. Included Device names should be formattable, with options for prefixes, suffixes, or omission of device type labels. Included Devices should include the model name, serial number, MAC address(es) and firmware version. Included <p>**Data Retrieval</p> Requirement Status The integration should retrieve device data, including connected clients for wireless devices (MR, GR) Included The integration should retrieve device data, including connected clients for appliances (MX, GX). Included The integration should retrieve device data, including connected clients for network switches (MS, GS). Included Data should be updated at a configurable scan interval. Included <p>**Home Assistant Integration</p> Requirement Status The integration should create sensor, device tracker, and switch entities in Home Assistant. Included The integration must properly handle config entries, including setup, unloading, and reloading. Included The integration needs to have a configuration flow to take the API key and org id. Included The integration should have option flow, to set scan interval and device name format. Included The integration should handle re-authentication of the API key. Included <p>**Mapping Meraki objects to Home Assistant objects</p> Requirement Status Physical Meraki devices (Wireless, Switch, Appliance, Camera, Sensor) will have corresponding Home Assistant devices. Included Meraki networks will be shown as Home Assistant devices. Included Meraki SSIDs (wireless networks) will be shown as Home Assistant devices. Included Meraki VLANs will be shown as Home Assistant devices. Included <p>**Meraki Appliances</p> Requirement Status Meraki appliances should have sensors that track data usage. Included Meraki appliances should have a sensor that tracks the number of connected clients. Included Meraki appliances have VLANs; these VLANs should appear as Home Assistant devices. Included Meraki appliances have an external hostname; this should appear as details of the Home Assistant device. Included Meraki appliances should have a sensor that tracks the number of ports in use. Included Meraki appliances should have a sensor that tracks the number of ports available. Included Meraki appliances should show the status of the appliance uplinks Included <p>**Meraki Wireless</p> Requirement Status Meraki wireless devices should appear as Home Assistant devices Included Meraki wireless devices should have a sensor that tracks the number of connected clients. Included Meraki SSID names should appear as Home Assistant devices Included Disabled SSIDs should not be shown in the list Working SSID names should be updateable Included SSIDs should be able to have the \"Broadcast SSID\" feature enabled / disabled Fixed Meraki SSIDs should have sensors for splash page, auth mode, encryption mode, WPA encryption mode, IP assignment mode, band selection, per-client bandwidth limits, per-SSID bandwidth limits, and visibility Included <p>**Meraki Switches</p> Requirement Status If the Meraki switch supports PoE, the switch should have sensors that aggregated PoE usage. Included Meraki switches should have a sensor that tracks the number of ports in use. Included Meraki switches should have a sensor that tracks the number of ports available. Included <p>**Meraki Cameras</p> Requirement Status Meraki cameras should have a data element that reflects the URL of the camera stream. Included Meraki cameras should have a Home Assistant switch that enables RTSP streaming. Included <p>**Meraki Sensors</p> Requirement Status Meraki sensors should have appropriate sensor and switch values based on their model. Included"},{"location":"requirements/#technical-requirements","title":"Technical Requirements","text":"<p>**Asynchronous Operations</p> Requirement Status All API calls and Home Assistant interactions must be asynchronous. Included <p>**Error Handling</p> Requirement Status The integration should handle API errors, network issues, and other exceptions gracefully. Included Logging should be used for debugging and error reporting. Included <p>**Data Coordination</p> Requirement Status A DataUpdateCoordinator should be used to manage data updates and prevent excessive API calls. Included A separate coordinator should be created to manage the device creations. Included <p>**Configuration Flow</p> Requirement Status The integration must provide a configuration flow for users to enter their Meraki API credentials. Included <p>**Home Assistant API</p> Requirement Status The integration must adhere to the Home Assistant API guidelines and conventions. Included <p>**Use of AIOHTTP</p> Requirement Status The Integration uses AIOHTTP for the API calls. Included <p>**Use of Voluptuous</p> Requirement Status The Integration uses Voluptuous for schema validation. Included"},{"location":"requirements/#key-learnings-from-debugging","title":"Key Learnings from Debugging","text":"Requirement Status Import statements must be accurate and reflect the actual file structure and module names. Included Caching can cause significant issues, requiring aggressive cache clearing. Partially Included Thorough logging is essential for debugging. Included The removal of a base class requires the functionality to be moved to the child class. N/A The init.py file is the central location for the integration's logic. Included The use of the correct coordinator class is very important. Included"},{"location":"requirements/#future-work","title":"Future Work","text":"<p>**High Priority / Core Functionality</p> <ul> <li>[ ] Refactor to use <code>core</code> components: The highest priority is to refactor the codebase to use the new <code>core</code> components and remove the old, redundant code. This will involve updating the platforms to use the new <code>core</code> entities and coordinators, and removing the old API client, coordinators, and entities.</li> <li>[ ] Improve Error Handling and Logging: Enhance error catching, provide more user-friendly error messages, and ensure consistent logging across the integration.</li> <li>[ ] Optimize Data Retrieval: Review API call patterns to optimize for performance and minimize API rate limit impact, especially for large organizations.</li> <li>[ ] Real-time Updates: Investigate using webhooks or WebSockets for real-time data updates.</li> </ul> <p>**New Features / Entities</p> <ul> <li>[ ] Implement Switches for Internet Ports: Allow control over WAN/Internet ports on MX appliances if API supports.</li> <li>[ ] Device Services: Add services to reboot a device and blink its LEDs.</li> <li>[ ] Client List Sensor: Add a sensor that provides a list of connected clients as an attribute.</li> <li>[ ] Signal Strength and Data Usage Sensors for Connected Clients: Create sensors to monitor signal strength (RSSI, SNR) and data usage (upload/download) for individual clients connected to Meraki APs.</li> <li>[ ] More Sensor Types for SSIDs: Add sensors for additional SSID properties, e.g., security settings (WPA type), traffic statistics (data usage per SSID), active bands.</li> <li>[ ] Support for Additional Meraki Product Types/Features:</li> <li>[ ] More detailed MV camera features (e.g., motion events, specific stream controls beyond snapshot URLs if available).</li> <li>[ ] SM (Systems Manager) endpoint monitoring/management if relevant for HA.</li> <li>[ ] Deeper sensor data for MT series (e.g., historical data, more specific readings if available).</li> <li>[ ] More detailed switch port statistics (e.g., per-port traffic, PoE details beyond basic count).</li> <li>[ ] Firmware Update Sensors/Notifications: Entities to indicate available firmware updates for devices or networks.</li> <li>[ ] Network Health/Event Sensors: Monitor overall network health or specific Meraki events/alerts.</li> <li>[ ] Parental Controls &amp; Content Filtering (MX Security Appliances):</li> <li>[ ] Content Filtering Policy Switch: Create a <code>select</code> entity to switch between content filtering policies.</li> <li>[ ] \"Internet Time-Out\" Switch per Device: Create a <code>switch</code> entity to block internet access for specific clients.</li> <li>[ ] Guest Wi-Fi Management (MR Access Points):</li> <li>[ ] Guest Wi-Fi Password Control: Create a <code>text</code> entity to manage the guest Wi-Fi password.</li> <li>[ ] Enhanced Home Security &amp; Awareness (MV Cameras &amp; MT Sensors):</li> <li>[ ] Camera Motion Events: Create <code>binary_sensor</code> entities for camera motion events.</li> <li>[ ] Per-Client Presence Detection: Enhance the device tracker to show which AP a client is connected to.</li> <li>[ ] PoE Control for Smart Homes (MS Switches):</li> <li>[ ] Per-Port PoE Control: Create a <code>switch</code> entity for each PoE-capable port.</li> </ul> <p>**Enhancements / Bug Fixes</p> <ul> <li>[ ] Relaxed Tag Matching: Add an option to allow for relaxed tag matching when associating SSIDs with wireless devices.</li> <li>[ ] Configuration Option for SSID Sensor Selection: Allow users to choose which specific sensors (availability, channel, client count, etc.) they want to enable per SSID to reduce entity clutter.</li> <li>[ ] Customize Device and Entity Names: Provide more advanced configuration options for customizing how Meraki device and entity names are generated in Home Assistant.</li> <li>[ ] Full Home Assistant Branding Support: Ensure the integration meets all requirements for Home Assistant branding, including logos and documentation links.</li> <li>[ ] Address Specific Bugs:</li> <li>[ ] Review \"Radio profiles are not returned for all MR devices\" (from README known issues) and investigate if it's an API limitation or an integration issue.</li> <li>[ ] Fix SSID entity <code>device_info</code>: Correctly link to parent AP via <code>via_device</code> attribute in <code>MerakiEntity</code> for SSID-specific entities.</li> <li>[ ] Tag-based SSID Control Review: The current <code>MerakiSSIDSwitch</code> uses device tags to control SSID state. Evaluate if a more direct API method for enabling/disabling SSIDs per AP (if available and appropriate) would be better, or if the tag strategy is the most robust.</li> </ul> <p>**Documentation</p> <ul> <li>[ ] Troubleshooting Section: Add a comprehensive troubleshooting section to <code>README.md</code> covering common issues (API key errors, rate limits, device discovery problems).</li> <li>[ ] Configuration Guide: Create a more detailed guide on configuring the integration, including explanations of all options in the config flow and options flow.</li> <li>[ ] Update Documentation for SSID Device Creation: Ensure documentation clearly explains how SSIDs are represented as devices and how their entities are structured.</li> <li>[ ] MkDocs for Documentation Generation: Set up MkDocs (or similar like Sphinx) for generating more structured and navigable documentation, potentially hosted on GitHub Pages.</li> <li>[ ] Developer Documentation: Add notes or a separate document for developers looking to contribute, explaining the coordinator structure, API client usage, and entity creation patterns.</li> </ul> <p>**Code Quality &amp; Refactoring</p> <ul> <li>[ ] Unit and Integration Tests: Expand test coverage significantly.</li> </ul>"},{"location":"requirements/cameras/","title":"Camera Requirements","text":"<p>This document outlines the functional requirements for camera entities in the Meraki Home Assistant integration.</p>"},{"location":"requirements/cameras/#rtsp-stream-url-handling","title":"RTSP Stream URL Handling","text":"<p>The integration must provide a reliable RTSP stream URL for camera entities. The logic for determining this URL should follow a specific priority and fallback mechanism to ensure maximum reliability and user control.</p> <p>**R6: RTSP URL Logic</p> <p>The <code>stream_source</code> property of the <code>MerakiCamera</code> entity must implement the following logic:</p> <ol> <li> <p>Check <code>use_lan_ip</code> Setting: The primary factor determining the URL is the <code>use_lan_ip</code> option in the integration's configuration.</p> </li> <li> <p>If <code>use_lan_ip</code> is <code>True</code>:</p> </li> <li>Priority 1: Local API URL: Check if the RTSP URL provided by the Meraki API (<code>rtspUrl</code> from the video settings endpoint) is already a local IP address (i.e., it falls within a reserved private IP range like <code>192.168.0.0/16</code>, <code>10.0.0.0/8</code>, or <code>172.16.0.0/12</code>). If it is, use this URL.</li> <li>Priority 2: Construct Local URL: If the API-provided URL is not a local IP, attempt to construct a valid RTSP URL using the camera's <code>lanIp</code> property.</li> <li> <p>Fallback: Public API URL: If the <code>lanIp</code> is not available, fall back to using the public URL provided by the API as a last resort.</p> </li> <li> <p>If <code>use_lan_ip</code> is <code>False</code> (Default):</p> </li> <li>Priority 1: Public API URL: Prioritize using the RTSP URL provided by the Meraki API.</li> <li> <p>Fallback: Construct Local URL: If the URL from the API is missing, invalid (e.g., not a valid RTSP format), or unavailable, fall back to constructing a local URL using the camera's <code>lanIp</code> property.</p> </li> <li> <p>Validation: In all cases, before returning a URL, the integration must validate that it is a properly formatted RTSP URL (i.e., starts with <code>rtsp://</code>). If no valid URL can be found or constructed, the stream source should be <code>None</code>.</p> </li> </ol>"},{"location":"requirements/requirements/","title":"Requirements Verification (ha-camera-refactor2)","text":"<p>This document verifies the state of the codebase against the requirements for the camera refactoring task.</p> <ul> <li>R1: Complete Discovery:</li> <li>[VERIFIED] <code>MVHandler</code> discovers and creates the <code>MerakiCamera</code> entity.</li> <li> <p>[VERIFIED] <code>MVHandler</code> correctly passes <code>config_entry</code> and <code>CameraService</code> to the <code>MerakiCamera</code> entity during initialization.</p> </li> <li> <p>R2: RTSP Stream Control:</p> </li> <li>[FAIL] The <code>MerakiCamera</code> entity is missing the <code>turn_on</code> and <code>turn_off</code> methods required for stream control.</li> <li> <p>[VERIFIED] The <code>CameraService</code> has the necessary <code>async_set_rtsp_stream_enabled</code> method to control the stream.</p> </li> <li> <p>R3: Configuration Honored:</p> </li> <li> <p>[FAIL] The <code>MVHandler</code> does not currently check the <code>rtsp_stream_enabled</code> option at startup to proactively enable the stream.</p> </li> <li> <p>R4: API Robustness:</p> </li> <li> <p>[FAIL] The <code>core/utils/api_utils.py</code> module's <code>validate_response</code> function raises an exception on empty API responses, causing crashes instead of handling them gracefully. This is the source of the \"Empty response from API\" error.</p> </li> <li> <p>R5: Informative Feedback:</p> </li> <li>[PARTIAL] The <code>MerakiCamera</code> entity has some error handling for streams, but it needs to be improved to be more state-driven and provide clearer feedback through the coordinator. The <code>camera_repository.py</code> also needs to be improved to handle non-RTSP URLs.</li> </ul> <p>This verification confirms the need for the planned refactoring steps. The new requirements (R4, R5) are now considered part of the standard for this integration.</p>"},{"location":"requirements/web_ui_v1/","title":"Web-Based Configuration UI Requirements","text":"<p>This document outlines the requirements for a standalone web-based user interface (UI) to configure the <code>meraki_ha</code> Home Assistant integration. The UI should be a single-page application and should run on a web server started by the integration itself.</p>"},{"location":"requirements/web_ui_v1/#1-general-requirements","title":"1. General Requirements","text":"<ul> <li>Technology Stack: The UI will be a standalone single-page application using HTML, CSS, and JavaScript. It must not rely on any heavy front-end frameworks (e.g., React, Vue.js).</li> <li>Web Server: The integration's back-end component will provide a lightweight web server (e.g., using <code>aiohttp</code>) to serve the UI files and handle API requests.</li> <li>User Flow: The user will navigate to a specific URL (e.g., <code>http://&lt;ha_ip&gt;:&lt;ha_port&gt;/meraki_ha_config</code>) to access the UI.</li> <li>Communication: The UI will communicate with the back-end web server via a REST API to save and retrieve configuration data.</li> </ul>"},{"location":"requirements/web_ui_v1/#2-uiux-requirements","title":"2. UI/UX Requirements","text":"<ul> <li>Single-Page Layout: The UI should be contained within a single HTML page.</li> <li>Responsive Design: The UI must be responsive and usable on both desktop and mobile browsers.</li> <li>Branding: The UI should have a clean, modern design that is visually consistent with the Home Assistant aesthetic, though it doesn't need to be an exact replica.</li> <li>Form Validation: The UI must perform client-side validation on all input fields to ensure data is in the correct format before submission.</li> <li>User Feedback: The UI must provide clear and concise feedback to the user upon submission, indicating whether the configuration was saved successfully or if there were errors. This feedback should be non-intrusive (e.g., a temporary banner or message).</li> </ul>"},{"location":"requirements/web_ui_v1/#3-functional-requirements","title":"3. Functional Requirements","text":"<ul> <li>Configuration Form: The UI must display a form containing the configuration items. The specific fields will be provided separately.</li> <li>Save Functionality: There must be a \"Save\" button that, when clicked, collects all the form data and sends it to the back-end API.</li> <li>API Endpoints: The back-end web server must expose two API endpoints:</li> <li><code>GET /api/config</code>: This endpoint should retrieve the current saved configuration data and return it as a JSON object. The UI should use this to pre-populate the form fields on page load.</li> <li><code>POST /api/config</code>: This endpoint should accept a JSON payload containing the new configuration data. Upon successful processing, it should return a success message. If there's an error (e.g., invalid data), it should return an error message with a clear description.</li> <li>Error Handling: The UI must gracefully handle API errors. If the back-end returns an error, the UI should display the error message to the user.</li> <li>Confirmation: After a successful save, the UI should display a confirmation message and potentially offer a link to return to the main Home Assistant dashboard.</li> </ul>"},{"location":"requirements/web_ui_v2/","title":"Web UI Requirements for Home Assistant Integration","text":"<p>This document outlines the requirements for developing a self-hosted web interface for the Home Assistant integration.</p>"},{"location":"requirements/web_ui_v2/#1-strategic-intent","title":"1. Strategic Intent","text":"<p>The primary purpose of this web interface is to provide a user-friendly way to view the status of and configure the Meraki Home Assistant integration. It is not intended to replace the native Meraki Dashboard or the Home Assistant UI, but to supplement them with a dedicated control panel for this specific integration. Future development should prioritize adding controls for the integration's configuration options.</p>"},{"location":"requirements/web_ui_v2/#2-web-interface-implementation-plan","title":"2. Web Interface Implementation Plan","text":"<p>The web interface will be a modern, single-page application (SPA) served by a lightweight Python web server that is started and managed by the Home Assistant integration itself.</p> <p>**2.1. Technology Stack</p> <ul> <li>Backend/Web Server: <code>aiohttp</code>.</li> <li>Frontend Framework: React (using Vite for tooling).</li> <li>Styling: Tailwind CSS.</li> </ul> <p>**2.2. Architecture</p> <ol> <li>The integration will start an <code>aiohttp</code> web server on a user-configurable port.</li> <li>The server will serve a pre-built React application from <code>web_ui/dist</code>.</li> <li>The React app will consume REST API endpoints from the server to get data from the integration's coordinator.</li> </ol> <p>**2.3. API Endpoints</p> <ul> <li><code>GET /api/config</code>: General configuration.</li> <li><code>GET /api/networks</code>: List of all networks.</li> <li><code>GET /api/clients</code>: List of all clients.</li> <li><code>GET /api/networks/{id}</code>: Detailed information for a single network.</li> <li><code>GET /api/clients/{mac}</code>: Detailed information for a single client.</li> </ul>"},{"location":"requirements/web_ui_v2/#3-uiux-design-v2","title":"3. UI/UX Design (V2)","text":"<p>The application layout will be updated to a two-column design with a new color scheme.</p> <p>**3.1. Layout</p> <ul> <li>Left Column (Sidebar):</li> <li>A fixed-width, persistent sidebar for navigation.</li> <li>Links: Dashboard, Networks, Clients, Settings.</li> <li>Right Column (Main Content):</li> <li>Displays the content for the selected page.</li> </ul> <p>**3.2. Theming and Color Scheme</p> <ul> <li>Color Palette:</li> <li>Primary/Accent: Cisco Blue (e.g., <code>#00bceb</code>).</li> <li>Light Mode: Light grey background, white cards, dark grey text.</li> <li>Dark Mode: Very dark grey background, lighter dark grey cards, off-white text.</li> <li>Dark Mode Implementation:</li> <li>Must support automatic dark mode based on <code>prefers-color-scheme</code>.</li> <li>To be implemented using Tailwind CSS's <code>dark:</code> variant.</li> </ul> <p>**3.3. Card Layout</p> <ul> <li>The existing card-based layout will be maintained and enhanced.</li> <li>Cards should be designed to be flexible for future additions (more data, action buttons).</li> </ul>"},{"location":"requirements/web_ui_v2/#4-home-assistant-configuration","title":"4. Home Assistant Configuration","text":"<p>The following options will be managed via the integration's \"Configure\" panel.</p> <ul> <li><code>enable_web_ui</code>: (boolean, Default: <code>True</code>)</li> <li><code>web_ui_port</code>: (integer, Default: <code>9988</code>)</li> <li><code>hide_unconfigured_ssids</code>: (boolean, Default: <code>False</code>)</li> <li><code>ignored_networks</code>: (string, comma-separated list)</li> </ul>"},{"location":"requirements/web_ui_v2/#5-architecture-single-vs-multi-instance-web-ui","title":"5. Architecture: Single vs. Multi-Instance Web UI","text":"<p>Recommendation: Each integration hub should have its own web instance. This is for simplicity, stability, and data isolation.</p>"},{"location":"user/entities/","title":"Entities","text":"<p>This document describes the entities.</p>"},{"location":"user/setup/","title":"Configuration","text":"<p>This is the configuration guide.</p>"},{"location":"user/troubleshooting/","title":"Troubleshooting","text":"<p>This is the troubleshooting guide.</p>"}]}