name: Deploy Latest Code to Local Folder on Linux Runner

<<<<<<< HEAD
<<<<<<< HEAD
# This workflow will run on 'push' events to the specified branches.
on:
  push:
    branches:
      - main
      - beta # Trigger deployment on pushes/merges to the beta branch
=======
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
on:
  push:
    branches:
      - beta
<<<<<<< HEAD
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129

jobs:
  deploy-to-linux-folder:
    # This job runs on the self-hosted runner.
    runs-on: self-hosted
<<<<<<< HEAD
<<<<<<< HEAD
=======
    permissions:
      contents: read # Explicitly grant read permission for the GITHUB_TOKEN
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
    permissions:
      contents: read # Explicitly grant read permission for the GITHUB_TOKEN
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129

    # Define environment variables
    env:
      # This is the path inside your runner container, mapping to the Host OS config.
      DESTINATION_PATH: '/ha_config/custom_components/meraki_ha'

    steps:
      - name: Checkout repository
        # Checks out your repository code into $GITHUB_WORKSPACE.
<<<<<<< HEAD
<<<<<<< HEAD
        uses: actions/checkout@v5
=======
        uses: actions/checkout@v6
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
        uses: actions/checkout@v6
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129

      - name: Copy files to destination folder (rsync)
        # Use 'bash' and 'sudo rsync' to bypass symlink and permission issues.
        shell: bash
        env:
          DEPLOY_PATH: ${{ env.DESTINATION_PATH }}
        run: |
          # The source directory containing ONLY the component files (with trailing slash)
          SourceComponentDir="${GITHUB_WORKSPACE}/custom_components/meraki_ha/"
          DestinationPath="${DEPLOY_PATH}"

          echo "Starting deployment..."
          echo "Source path: ${SourceComponentDir}"
          echo "Destination path: ${DestinationPath}"

          # 1. Create the destination directory if it doesn't exist
          # Use sudo to elevate permissions for file system operations.
          # The -p flag prevents an error if the directory already exists.
          sudo mkdir -p "${DestinationPath}"

          # 2. Copy files using rsync for robustness
<<<<<<< HEAD
<<<<<<< HEAD
          # rsync -ah --delete: 
=======
          # rsync -ah --delete:
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
          # rsync -ah --delete:
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
          #   -a: archive mode (preserves permissions, timestamps, etc.)
          #   -h: human-readable output
          #   --delete: removes files from destination that aren't in source (ensures clean state)

          # CRITICAL: Exclude development files/symlinks to avoid 'Operation not supported' errors.
          sudo rsync -rltpD --inplace --delete \
            --exclude '.git' \
            --exclude 'node_modules' \
            --exclude 'tests' \
            --exclude '*.log' \
            --exclude 'docker-runner' \
<<<<<<< HEAD
<<<<<<< HEAD
            --exclude 'custom_components' \
=======
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
            "${SourceComponentDir}" "${DestinationPath}"

          echo "Successfully copied latest code to ${DestinationPath}."
          echo "Deployment complete."

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
      - name: Clear Home Assistant Frontend Cache
        shell: bash
        env:
          HA_URL: ${{ secrets.HA_URL }}
          HA_TOKEN: ${{ secrets.HA_TOKEN }}
        run: |
          echo "Clearing Home Assistant frontend cache..."
          CLEAN_HA_TOKEN=$(echo -n "$HA_TOKEN" | tr -d '\n\r')
          API_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
              -H "Authorization: Bearer $CLEAN_HA_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{}" \
              "$HA_URL/api/services/frontend/reload_themes")
          if [[ "$API_STATUS" -ne 200 ]]; then
              echo "Warning: Failed to clear frontend cache. HTTP status code: $API_STATUS."
          else
              echo "Home Assistant frontend cache cleared."
          fi
<<<<<<< HEAD
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
      - name: Restart Home Assistant
        shell: bash
        env:
          HA_URL: ${{ secrets.HA_URL }}
          HA_TOKEN: ${{ secrets.HA_TOKEN }}
        run: |
          echo "Attempting to restart Home Assistant..."

          # Sanitize the Home Assistant token to remove any trailing newlines or whitespace.
          CLEAN_HA_TOKEN=$(echo -n "$HA_TOKEN" | tr -d '\n\r')

          # Step 1a: Basic Connectivity Test
          echo "Testing basic connectivity to Home Assistant..."
          API_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -X GET \
              -H "Authorization: Bearer $CLEAN_HA_TOKEN" \
              -H "Content-Type: application/json" \
              "$HA_URL/api/")

          if [[ "$API_STATUS" -ne 200 ]]; then
              echo "Error: Could not connect to the Home Assistant API. HTTP status code: $API_STATUS."
              echo "Please verify that the HA_URL secret is set correctly and that your Home Assistant instance is running."
              echo "Attempted URL: $HA_URL/api/"
              exit 1
          else
              echo "Connectivity test passed."
          fi

          # Step 1b: Check Configuration
          echo "Checking Home Assistant configuration..."
          BODY_FILE=$(mktemp) # Create a temporary file to store the response body.

          # Make the API call and capture the HTTP status code.
          HTTP_STATUS=$(curl -sS -o "$BODY_FILE" -w "%{http_code}" -X POST \
              -H "Authorization: Bearer $CLEAN_HA_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{}" \
              "$HA_URL/api/config/core/check_config")

          CHECK_RESULT=$(cat "$BODY_FILE")
          rm "$BODY_FILE" # Clean up the temporary file.

          # Check for non-2xx status codes (e.g., 404 Not Found, 401 Unauthorized).
          if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
              echo "Error: API call to check config failed with HTTP status code $HTTP_STATUS."
              if [[ "$HTTP_STATUS" -eq 404 ]]; then
                  echo "A 404 error here often means the 'config' integration is not enabled in your Home Assistant's configuration.yaml."
              fi
              echo "Please check that the HA_URL secret is correct and the server is reachable."
              echo "URL: $HA_URL/api/config/core/check_config"
              echo "Response: $CHECK_RESULT"
              exit 1
          fi

          # Verify that the successful response is valid JSON before trying to parse it.
          if ! echo "$CHECK_RESULT" | grep -q '^{'; then
            echo "Error: API response with status $HTTP_STATUS does not appear to be valid JSON."
            echo "Received response:"
            echo "$CHECK_RESULT"
            exit 1
          fi

          ERRORS=$(echo "$CHECK_RESULT" | jq -r '.errors')

          if [ "$ERRORS" != "null" ] && [ "$ERRORS" != "" ]; then
            echo "Config check failed! Errors:"
            echo "$CHECK_RESULT" | jq
            exit 1 # Stop the pipeline
          else
            echo "Config check passed."
          fi

          # Step 1b: Trigger Restart
          echo "Triggering Home Assistant restart..."
<<<<<<< HEAD
<<<<<<< HEAD
          RESTART_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -X POST \
              -H "Authorization: Bearer $CLEAN_HA_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{}" \
              "$HA_URL/api/services/home_assistant/restart")

          if [[ "$RESTART_STATUS" -lt 200 || "$RESTART_STATUS" -ge 300 ]]; then
              echo "Error: API call to restart failed with HTTP status code $RESTART_STATUS."
=======
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
          RESTART_RESPONSE_FILE=$(mktemp)
          RESTART_STATUS=$(curl -sS -o "$RESTART_RESPONSE_FILE" -w "%{http_code}" -X POST \
              -H "Authorization: Bearer $CLEAN_HA_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{}" \
              "$HA_URL/api/services/homeassistant/restart")
          RESTART_RESPONSE=$(cat "$RESTART_RESPONSE_FILE")
          rm "$RESTART_RESPONSE_FILE"

          if [[ "$RESTART_STATUS" -lt 200 || "$RESTART_STATUS" -ge 300 ]]; then
              echo "Error: API call to restart failed with HTTP status code $RESTART_STATUS."
              echo "Response: $RESTART_RESPONSE"
<<<<<<< HEAD
>>>>>>> origin/fix/meraki-load-fail-cleanup-7732058548349983668
=======
>>>>>>> origin/fix/wireless-ipsk-crash-14368601733312930129
              exit 1
          fi

          echo "Home Assistant restart command sent. Waiting for it to come back online..."
          # Add a sleep to allow Home Assistant to restart
          sleep 60 # Wait for 60 seconds. Adjust as needed.
